<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>cfitsTK: AOloopControl</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cfitsTK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_src_AOloopControl_doc_AOloopControl.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">AOloopControl </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>% AOloopControl % Olivier Guyon % May 29, 2017</p>
<h1><a class="anchor" id="AOloopControl_UserGuide"></a>
Initial Setup</h1>
<h2>Scope</h2>
<p>AO loop control package</p>
<h2>Pre-requisites</h2>
<p>Libraries required :</p>
<ul>
<li>gcc</li>
<li>openMP</li>
<li>fitsio</li>
<li>fftw (single and double precision)</li>
<li>gsl</li>
<li>readline</li>
<li>tmux</li>
</ul>
<p>Recommended:</p>
<ul>
<li>CUDA</li>
<li>Magma</li>
<li>shared memory image viewer (<code>shmimview</code> or similar)</li>
</ul>
<h2>Installing the AdaptiveOpticsControl package</h2>
<p>Source code is available on the <a href="https://github.com/oguyon/AdaptiveOpticsControl">AdaptiveOpticsControl git hub repository</a>.</p>
<p>Download the latest tar ball (.tar.gz file), uncompress, untar and execute in the source directory (<code>./AdaptiveOpticsControl-&lt;version&gt;/</code>) </p><pre class="fragment">./configure
</pre><p>Include recommended high performance compile flags for faster execution speed: </p><pre class="fragment">./configure CFLAGS='-Ofast -march=native'
</pre><p>If you have installed CUDA and MAGMA libraries: </p><pre class="fragment">./configure CFLAGS='-Ofast -march=native' --enable-cuda --enable-magma
</pre><p>The executable is built with: </p><pre class="fragment">make
make install
</pre><p>The executable is <code>./AdaptiveOpticsControl-&lt;version&gt;/bin/AdaptiveOpticsControl</code></p>
<h2>Setting up the work directory</h2>
<p>Conventions:</p>
<ul>
<li><code>&lt;srcdir&gt;</code> is the source code directory, usually <code>.../AdaptiveOpticsControl-&lt;version&gt;</code></li>
<li><code>&lt;workdir&gt;</code> is the work directory where the program and scripts will be executed. Note that the full path should end with <code>.../AOloop&lt;#&gt;</code> where <code>&lt;#&gt;</code> ranges from 0 to 9. For example, <code>AOloop2</code>.</li>
</ul>
<p>The work directory is where all scripts and high level commands should be run from. You will first need to create the work directory and then load scripts from the source directory to the work directory by executing from the source directory the 'syncscript -e' command: </p><pre class="fragment">mkdir /&lt;workdir&gt;
cd &lt;srcdir&gt;/src/AOloopControl/scripts
./syncscripts -e /&lt;workdir&gt;
cd /&lt;workdir&gt;
./syncscripts
</pre><p>Symbolic links to the source scripts and executable are now installed in the work directory : </p><pre class="fragment">olivier@ubuntu:/data/AOloopControl/AOloop1$ ls -l
total 28
drwxrwxr-x 2 olivier olivier 4096 Feb 21 18:14 aocustomscripts
drwxrwxr-x 2 olivier olivier 4096 Feb 21 18:14 aohardsim
lrwxrwxrwx 1 olivier olivier   57 Feb 21 18:14 aolconf -&gt; /home/olivier/src/Cfits/src/AOloopControl/scripts/aolconf
drwxrwxr-x 2 olivier olivier 4096 Feb 21 18:14 aolconfscripts
lrwxrwxrwx 1 olivier olivier   70 Feb 21 19:08 AOloopControl -&gt; /home/olivier/src/Cfits/src/AOloopControl/scripts/../../../bin/cfitsTK
drwxrwxr-x 2 olivier olivier 4096 Feb 21 18:14 aosetup
drwxrwxr-x 2 olivier olivier 4096 Feb 21 18:14 auxscripts
lrwxrwxrwx 1 olivier olivier   61 Feb 21 18:13 syncscripts -&gt; /home/olivier/src/Cfits/src/AOloopControl/scripts/syncscripts
</pre><p>If new scripts are added in the source directory, running <code>./syncscripts</code> again from the work directory will add them to the work directory.</p>
<p>The main executable is <code>./AOloopControl</code>, which provides a command line interface (CLI) to all compiled code. Type <code>AOloopControl -h</code> for help. You can enter the CLI and list the available libraries (also called modules) that are linked to the CLI. You can also list the functions available within each module (<code>m? &lt;module.c&gt;</code>) and help for each function (<code>cmd? &lt;functionname&gt;</code>). Type <code>help</code> within the CLI for additional directions.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;olivier@ubuntu:/data/AOloopControl/AOloop1$ ./AOloopControl </div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;type &quot;help&quot; for instructions</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Running with openMP, max threads = 8  (defined by environment variable OMP_NUM_THREADS)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;LOADED: 21 modules, 269 commands</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;./AOloopControl &gt; m?</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    0            cudacomp.c    CUDA wrapper for AO loop</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    1  AtmosphericTurbulence.c    Atmospheric Turbulence</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    2     AtmosphereModel.c    Atmosphere Model</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    3                 psf.c    memory management for images and variables</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    4       AOloopControl.c    AO loop control</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    5           AOsystSim.c    conversion between image format, I/O</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    6    AOloopControl_DM.c    AO loop Control DM operation</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    7         OptSystProp.c    Optical propagation through system</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    8        ZernikePolyn.c    create and fit Zernike polynomials</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    9         WFpropagate.c    light propagation</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;   10         image_basic.c    basic image routines</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   11        image_filter.c    image filtering</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;   12           image_gen.c    creating images (shapes, useful functions and patterns)</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;   13      linopt_imtools.c    image linear decomposition and optimization tools</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;   14           statistic.c    statistics functions and tools</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;   15                 fft.c    FFTW wrapper</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;   16                info.c    image information and statistics</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;   17       COREMOD_arith.c    image arithmetic operations</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;   18      COREMOD_iofits.c    FITS format input/output</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;   19      COREMOD_memory.c    memory management for images and variables</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;   20       COREMOD_tools.c    image information and statistics</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;./AOloopControl &gt; exit</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;Closing PID 5291 (prompt process)</div>
</div><!-- fragment --><p>The top level script is <code>aolconf</code>. Run it with <code>-h</code> option for a quick help </p><pre class="fragment">./aolconf -h
</pre><h2>Supporting scripts, aolconfscripts directory</h2>
<p>Scripts in the <code>aolconfscripts</code> directory are part of the high-level ASCII control GUI</p>
<hr/>
<p> Script Description </p><hr/>
<p> <b>aolconf_DMfuncs</b> DM functions</p>
<p><b>aolconf_DMturb</b> DM turbulence functions</p>
<p><b>aolconf_funcs</b> Misc functions</p>
<p><b>aolconf_logfuncs</b> data and command logging</p>
<p><b>aolconf_menuconfigureloop</b> configure loop menu</p>
<p><b>aolconf_menucontrolloop</b> control loop menu</p>
<p><b>aolconf_menucontrolmatrix</b> control matrix menu</p>
<p><b>aolconf_menu_mkFModes</b> Make modes</p>
<p><b>aolconf_menurecord</b></p>
<p><b>aolconf_menutestmode</b> Test mode menu</p>
<p><b>aolconf_menutop</b> Top level menu</p>
<p><b>aolconf_menuview</b> Data view menu</p>
<p><b>aolconf_readconf</b> Configuration read functions</p>
<p><b>aolconf_template</b> Template (not used) </p><hr/>
<h2>Supporting scripts (./auxscripts directory)</h2>
<p>Scripts in the <code>auxscripts</code> directory are called by aolconf to perform various tasks. To list all commands, type in the <code>auxscripts</code> directory : </p><pre class="fragment">./listcommands
</pre><p>The available commands are listed in the table below. Running the command with the <code>-h</code> option prints a short help.</p>
<hr/>
<p> Script Description </p><hr/>
<p> ./mkHpoke Compute real-time WFS residual image</p>
<p>./aolMeasureTiming Measure loop timing</p>
<p>./aolCleanLOrespmat Measure zonal resp matrix</p>
<p>./aolRMmeas_sensitivity Measure photon sensitivity of zonal response matrix </p><pre class="fragment">           ./aolmon       Display AO loop stats

        ./acquRespM       Acquire response matrix

           ./aolctr       AO control process

      ./listrunproc       List running AOloop processes

   ./MeasDMmodesRec       Measure AO loop DM modes recovery

     ./aolARPFblock       AO find optimal AR linear predictive filter (single block)

         ./aolRM2CM       Align Pyramid camera

 ./aolCleanZrespmat       Cleans zonal resp matrix

 ./mkDMslaveActprox       Create DM slaved actuators map

           ./xptest       Compute cross-product of a data cube

  ./aolInspectDMmap       Inspect DM map

./aolARPFautoUpdate       Automatic update of AR linear predictive filter

./aolCleanZrespmat2       Cleans zonal resp matrix

     ./mkDMslaveAct       Create DM slaved actuators map

  ./aolReadConfFile       AOloop load file to stream

        ./aolLinSim       AO Linear Simulator

     ./aolApplyARPF       Apply AR linear predictive filter

          ./aolARPF       AO find optimal AR linear predictive filter

    ./aolSetmcLimit       Compute real-time WFS residual image

 ./aolautotunegains       Automatic gain tuning

       ./aolmkMasks       Create AO wfs and DM masks

      ./aolmkmodesM       CREATE CM MODES FOR AO LOOP, MODAL DM
</pre><p>./aolMeasureLOrespmat Acquire modal response matrix </p><pre class="fragment">     ./waitonfile       Wait for file to appear

./predFiltApplyRT       Apply predictive filter to stream

 ./aoloffloadloop       DM offload loop

    ./aolmkWFSres       Compute real-time WFS residual image
</pre><p>./aolWFSresoffloadloop Compute real-time WFS residual image </p><pre class="fragment">  ./aollindm2wfsim       Convert DM stream to WFS image stream
</pre><p>./aolApplyARPFblock Apply AR linear predictive filter (single block)</p>
<p>./aolmcoeffs2dmmap GPU-based MODE COEFFS -&gt; DM MAP </p><pre class="fragment">  ./aolmkmodes       Create modes for AO loop
</pre><p>./aolMeasureZrespmat2 Acquire zonal response matrix</p>
<p>./processTelemetryPSDs Process telemetry: create open and closed loop PSDs </p><pre class="fragment">     ./aolzploopon       WFS zero point offset loop 

  ./aollinsimDelay       Introduce DM delay

       ./shmimzero       Set shared memory image stream to zero

     ./aolmkmodes2       Create modes for AO loop

      ./alignPyrTT       Align Pyramid TT

 ./aolgetshmimsize       Get shared memory image size
</pre><p>./aolMeasureZrespmat Acquire zonal response matrix </p><pre class="fragment">       ./xp2test       Compute cross-product of two data cubes

  ./waitforfilek       Wait for file to appear and then remove it
</pre><p>./aolmkLO_DMmodes Create LO DM modes for AO loop </p><pre class="fragment">./aolscangain       AO scan gain for optimal value

 ./aol_dmCave       dmC temporal averaging

  ./alignPcam       Align Pyramid camera
</pre><p>./aolMeasureLOrespmat2 Acquire modal response matrix </p><pre class="fragment">  ./MeasureLatency       Measure AO system response latency

./aolARPFautoApply       Apply real-time AR linear predictive filter
</pre><p>./aolPFcoeffs2dmmap GPU-based predictive filter coeffs -&gt; DM MAP</p>
<p>./modesextractwfs Extract mode values from WFS images </p><pre class="fragment">   ./Fits2shm       Copy FITS files to shared memor
</pre><p>./aolblockstats Extract mode values from WFS images, sort per block </p><pre class="fragment">   ./aolrun       Run AO control loop
</pre><p>./aolMergeRMmat Merge HO and LO resp matrices</p>
<p>./selectLatestTelemetry Compute real-time WFS residual image </p><pre class="fragment"> ./MeasLoopModeResp       Measure AO loop temporal response
</pre> <hr/>
<h2>Hardware simulation scripts</h2>
<p>Scripts in the <code>aohardsim</code> directory are called to simulate hardware for testing / simulations.</p>
<hr/>
<p> Script Description </p><hr/>
<p> <b>aosimDMstart</b> Start simulation DM shared mem</p>
<p><b>aosimDMrun</b> Simulates physical deformable mirror (DM)</p>
<p><b>aosimmkWF</b> creates properly sized wavefronts from pre-computed wavefronts</p>
<p><b>aosimWPyrFS</b> Simulates WFS </p><hr/>
<h1>Hardware Simulation</h1>
<h2>Overview</h2>
<p>There are 3 methods for users to simulate hardware</p>
<ul>
<li>METHOD 1: Provide an external simulation that adheres to AOloopControl input/output conventions</li>
<li>METHOD 2: Use the physical hardware simulation provided by the package</li>
<li>METHOD 3: Use the linear hardware simulation: this option is fastest, but only captures linear relationships between DM actuators and WFS signals</li>
</ul>
<h2>METHOD 1: Provide an external simulation that adheres to AOloopControl input/output conventions</h2>
<p>The user runs a loop that updates the wavefront sensor image when the DM input changes. Both the DM and WFS are represented as shared memory image streams. When a new DM shape is written, the DM stream semaphores are posted by the user, triggering the WFS image computation. When the WFS image is computed, its semaphores are posted.</p>
<h2>METHOD 2: Physical hardware simulation</h2>
<p>The AOsim simulation architecture relies on individual processes that simulate subsystems. Each process is launched by a bash script. ASCII configuration files are read by each process. Data I/O can be done with low latency using shared memory and semaphores: a process operation (for example, the wavefront sensor process computing WFS signals) is typically triggered by a semaphore contained in the shared memory wavefront stream. A low-speed file system based alternative to shared memory and semaphores is also provided.</p>
<h3>Running Method 2</h3>
<p>Launch the simulator with the following steps:</p>
<ul>
<li><p class="startli">Create a series of atmospheric wavefronts (do this only once, this step can take several hrs): </p><pre class="fragment">  ./aohardsim/aosimmkwf
</pre><p class="startli">Stop the process when a few wavefront files have been created (approximately 10 minimum). The AO code will loop through the list of files created, so a long list is preferable to reduce the frequency at which the end-of-sequence discontinuity occurs. The current wavefront file index is displayed as the process runs; in this example, the process is working on file #2: </p><pre class="fragment">Layer  0/ 7, Frame   99/ 100, File      0/100000000  [TIME =     0.0990 s]  WRITING SCIENCE WAVEFRONT ... - 
Layer  0/ 7, Frame   99/ 100, File      1/100000000  [TIME =     0.1990 s]  WRITING SCIENCE WAVEFRONT ... - 
Layer  1/ 7, Frame   42/ 100, File      2/100000000  [TIME =     0.2420 s]  
</pre><p class="startli">Type <code>CTRL-C</code> to stop the process. Note that you can relaunch the script later to build additional wavefront files.</p>
<p class="startli">By default, the wavefront files are stored in the work directory. You may choose to move them to another location (useful if you have multiple work directories sharing the same wavefront files). You can then create a symbolic link <code>atmwf</code> to an existing atmospheric wavefront simulation directory. For example: </p><pre class="fragment">ln -s /data/AtmWF/wdir00/ atmwf
</pre></li>
<li>Execute master script <code>./aohardsim/runAOhsim</code></li>
<li>To stop the physical simulator: <code>./aohardsim/runAOhsim -k</code></li>
</ul>
<p>Important notes:</p>
<ul>
<li>Parameters for the simulation can be changed by editing the <code>.conf</code> files in the <code>aohardsim</code> directory</li>
<li>You may need to kill and relaunch the main script twice after changing parameters</li>
</ul>
<h3>Processes and scripts details</h3>
<h4>Process <code>aosimmkWF</code></h4>
<p><code>aosimmkWF</code> reads precomputed wavefronts and formats them for the simulation parameters (pixel scale, temporal sampling).</p>
<p>Parameters for <code>aosimmkWF</code> are stored in configuration file:</p>
<p>File <code>aosimmkWF.conf.default</code> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;!INCLUDE &quot;../scripts/aohardsim/aosimmkWF.conf.default&quot;</div>
</div><!-- fragment --><h4>Process <code>aosimDMrun</code></h4>
<p>File <code>aosimDMrun.conf.default</code> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;!INCLUDE &quot;../scripts/aohardsim/aosimDMrun.conf.default&quot;</div>
</div><!-- fragment --><h4>Process <code>aosimPyrWFS</code></h4>
<p>File <code>aosimPyrWFS.conf.default</code> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;!INCLUDE &quot;../scripts/aohardsim/aosimPyrWFS.conf.default&quot;</div>
</div><!-- fragment --><h3>AO loop control</h3>
<p>The <code>aolconf</code> script is used to configure and launch the AO control loop. It can be configured with input/output from real hardware or a simulation of real hardware.</p>
<h4>Shared memory streams</h4>
<hr/>
<p> Script Description </p><hr/>
<p> <b>wf0opd</b> Wavefront OPD prior to wavefront correction [um]</p>
<p><b>wf1opd</b> Wavefront OPD after correction [um] ( = wf0opd - 2 x dm05dispmap )</p>
<p><b>dm05disp</b> DM actuators positions</p>
<p><b>dm05dispmap</b> DM OPD map</p>
<p><b>WFSinst</b> Instantaneous WFS intensity</p>
<p><b>pWFSint</b> WFS intensity frame, time averaged to WFS frame rate and sampled to WFS camera pixels </p><hr/>
<h4>Hardware simulation architecture</h4>
<div class="image">
<img src="./figures/aosimlink.jpg"  alt="data flow" title="aosim data flow"/>
</div>
<p>Close-loop simulation requires the following scripts to be launched to simulate the hardware, in the following order :</p>
<ul>
<li><code>aosimDMstart</code>: This script creates DM channels (uses dm index 5 for simulation). Shared memory arrays <code>dm05disp00</code> to <code>dm05disp11</code> are created, along with the total displacement <code>dm05disp</code>. Also creates the <code>wf1opd</code> shared memory stream which is needed by <code>aosimDMrun</code> and will be updated by runWF. <code>wf1opd</code> is the master clock for the whole simulation, as it triggers DM shape computation and WFS image computation.</li>
<li><code>aosimDMrun</code>: Simulates physical deformable mirror (DM)</li>
<li><code>aosimmkWF</code>: Creates atmospheric wavefronts</li>
<li><code>aosimWFS</code>: Simulates WFS</li>
</ul>
<p>Some key script variables need to coordinated between scripts. The following WF array size should match :</p>
<ul>
<li><code>WFsize</code> in script <code>aosimDMstart</code></li>
<li><code>ARRAYSIZE</code> in <code>aosimmkWF.conf</code></li>
<li><code>ARRAYSIZE</code> in <code>aosimDMrun.conf</code></li>
</ul>
<p>The main hardware loop is between <code>aosimmkWF</code> and <code>aosimWFS</code>: computation of a wavefront by <code>aosimmkWF</code> is <em>triggered</em> by completion of a WFS instantaneous image computation by <code>aosimWFS</code>. The configuration files are configured for this link.</p>
<h4>DM temporal response</h4>
<p>The DM temporal response is assumed to be such that the distance between the current position $p$ and desired displacement $c$ values is multiplided by coefficient $a&lt;1$ at each time step $dt$. The corresponding step response is :</p>
<p>$c - p((k+1) dt) = (c - p(k dt)) a$</p>
<p>$c - p(k dt) = (c-p0) a^k$</p>
<p>$p(k dt) = 1-a^k$</p>
<p>The corresponding time constant is</p>
<p>$a^{{t0}{dt}} = 0.5$</p>
<p>${t0}{dt} ln(a) = ln(0.5)$</p>
<p>$ln(a) = ln(0.5) dt/t0$</p>
<p>$a = 0.5^{{dt}{t0}}$</p>
<h3>Processes and scripts: system ouput</h3>
<p>The output (corrected) wavefront is processed to compute ouput focal plane images, and optionally LOWFS image.</p>
<h4>Process <code>aosimcoroLOWFS</code></h4>
<p>Computes coronagraphic image output and LOWFS image</p>
<p>File <code>aosimcoroLOWFS.conf.default</code>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;!INCLUDE &quot;../scripts/aohardsim/aosimcoroLOWFS.conf.default&quot;</div>
</div><!-- fragment --><h4>Ouput simulation architecture</h4>
<div class="image">
<img src="./figures/aosimlink_coroLOWFS.jpg"  alt="coroLOWFS data flow" title="coroLOWFS data flow"/>
</div>
<h2>METHOD 3: Linear Hardware Simulation</h2>
<h3>Overview</h3>
<p>The Linear Hardware Simulation (LHS) uses a linear response matrix to compute the WFS image from the DM state. It is significantly faster than the Physical Hardware Simulation (PHS) but does not capture non-linear effects.</p>
<h1>AOloopControl setup and overview</h1>
<h2>GUI description</h2>
<p>The script <code>aolconf</code> starts the main GUI, from which all setup and control can be done. The GUI consists of several main screens, as shown below.</p>
<div class="image">
<img src="./figures/aolconfGUIscreens.jpg"  alt="aolconf GUI screens" title="GUI screens"/>
</div>
<h2>Commands log</h2>
<h3>Automatically generated internal log (very detailed)</h3>
<p>All commands are logged in an ASCII file. <code>aolconf</code> uses the script <code>aolconfscripts/aollog</code> to log into file <code>./logdir/&lt;UTDATE&gt;/logging/&lt;LOOPNAME&gt;.log</code>. A sym link to <code>aolconf.log</code> is created for convenience, so the log content can be viewed with:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;tail -f aolconf.log</div>
</div><!-- fragment --><p>Inside the bash script, function <code>aoconflog</code> is used to call <code>aolconfscripts/aollog</code> with the proper loop name.</p>
<h3>External log (less verbose)</h3>
<p>The user can provide a command to externally log commands. The executable should be in the path, and named <code>dologext</code>. The syntax is:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;dologext &lt;string&gt;</div>
</div><!-- fragment --><p>The string usually consists of the loop name followed by comments.</p>
<p>Inside the bash script, function <code>aoconflogext</code> is used to call <code>aolconfscripts/aollog</code> with the proper loop name.</p>
<h3>Interactive user log</h3>
<p>To start the interactive log script:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./aolconfscripts/aollog -i &lt;LOOPNAME&gt; NULL</div>
</div><!-- fragment --><p>Entries will be logged in the <code>./logdir/&lt;UTDATE&gt;/logging/&lt;LOOPNAME&gt;.log</code> file (with sym link to <code>aolconf.log</code>).</p>
<p>It is also common practice to start a <code>MISC</code> log for misc comments, also to be included in the external log:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./aolconfscripts/aollog -ie MISC NULL</div>
</div><!-- fragment --><h1>Setting up the hardware interfaces</h1>
<h2>Top level script</h2>
<p>Start aolconf with loop number and loop name (you can ommit these arguments when launching the script again):</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./aolconf -L 3 -N testsim</div>
</div><!-- fragment --><p>The loop name (<code>testsim</code> in the above example) will both allocate a name for the loop and execute an optional custom setup script. The software package comes with a few such pre-made custom scripts for specific systems / examples. When the <code>-N</code> option is specified, the custom setup script <code>./setup/setup_&lt;name&gt;</code> is ran. The script may make some of the steps described below optional.</p>
<p>You can check the current loop number and name settings with:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./aolconf -h</div>
</div><!-- fragment --><p>The script can also launch a pre-written CPU/OS configuration script named <code>./aocscripts/cpuconfig_&lt;LOOPNAME&gt;</code> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./aolconf -C</div>
</div><!-- fragment --><h2>Setting the DM interface</h2>
<p>There are four options for setting up the DM:</p>
<ul>
<li>[A] Connect to an existing DM</li>
<li>[B] Create a new DM and connect to it</li>
<li>[C] Create a new modal DM, mapped to an existing DM using another loop's control modes</li>
<li>[D] Create a new modal DM, mapped to an existing DM channel using a custom set of modes</li>
</ul>
<p>Before choosing an option, select if the DM to be controlled is <code>MODAL</code> or <code>ZONAL</code>. A zonal DM is one where the DM pixel locations map to physical actuator locations on the DM, allowing spatial filtering when creating control modes. With a zonal DM, each pixel of the DM map corresponds to a wavefront control mode, and spatial filtering functions are turned off.</p>
<p>Options [C] and [D] are <code>MODAL</code> options, as the DM does not represent physical spatial actuators. These options build a virtual DM which controls another DM.</p>
<h3>Mode [A]: Connecting to an existing DM</h3>
<ol type="1">
<li><b>Set DM number</b> (<code>S</code> command in <code>Top Menu</code> screen). You should see its x and y size in the two lines below. If not, the DM does not exist yet (see next section).</li>
<li><b>autoconfigure DM: main DM (nolink)</b> (<code>nolink</code> in <code>Top Menu</code> screen). This command automactically sets up the following symbolic links:<ul>
<li>dm##disp00 is linked to aol::_dmO (flat offset channel)</li>
<li>dm##disp02 is linked to aol::_dmRM (response matrix actuation channel)</li>
<li>dm##disp03 is linked to aol::_dmC (loop dm control channel)</li>
<li>dm##disp04 is linked to aol::_dmZP0 (zero point offset 0 actuation channel)</li>
<li>dm##disp05 is linked to aol::_dmZP1 (zero point offset 1 actuation channel)</li>
<li>dm##disp06 is linked to aol::_dmZP2 (zero point offset 2 actuation channel)</li>
<li>dm##disp07 is linked to aol::_dmZP3 (zero point offset 3 actuation channel)</li>
<li>dm##disp08 is linked to aol::_dmZP4 (zero point offset 4 actuation channel)</li>
<li>dm##disp is linked to aol::_dmdisp (total dm displacement channel)</li>
</ul>
</li>
<li><b>load Memory</b> (<code>M</code> in <code>Top Menu</code> screen). The dm performs the symbolic links to the DM channels.</li>
</ol>
<h3>Mode [B]: Creating and Connecting to a DM</h3>
<ol type="1">
<li>Set <b>DM number</b> (<code>S</code> command in <code>Top Menu</code> screen).</li>
<li>Enter the desired <b>DM size</b> with the <code>dmxs</code> and <code>dmys</code> commands.</li>
</ol>
<ul>
<li>OPTIONAL: <b>set DM delay</b> ('setDMdelayON' and 'setDMdelayval' in <code>Top Menu</code> screen)</li>
</ul>
<ol type="1">
<li><b>Create the DM streams</b> with the <code>initDM</code> command in the <code>Top Menu</code>. You may need to run the <code>stopDM</code> command first.</li>
<li><b>autoconfigure DM: main DM (nolink)</b> (<code>nolink</code> in <code>Top Menu</code> screen). This command automactically sets up the following symbolic links:<ul>
<li>dm##disp00 is linked to aol::_dmO (flat offset channel)</li>
<li>dm##disp02 is linked to aol::_dmRM (response matrix actuation channel)</li>
<li>dm##disp03 is linked to aol::_dmC (loop dm control channel)</li>
<li>dm##disp04 is linked to aol::_dmZP0 (zero point offset 0 actuation channel)</li>
<li>dm##disp05 is linked to aol::_dmZP1 (zero point offset 1 actuation channel)</li>
<li>dm##disp06 is linked to aol::_dmZP2 (zero point offset 2 actuation channel)</li>
<li>dm##disp07 is linked to aol::_dmZP3 (zero point offset 3 actuation channel)</li>
<li>dm##disp08 is linked to aol::_dmZP4 (zero point offset 4 actuation channel)</li>
<li>dm##disp is linked to aol::_dmdisp (total dm displacement channel)</li>
</ul>
</li>
<li><b>Load Memory</b> (<code>M</code> in <code>Top Menu</code> screen). The dm performs the symbolic links to the DM channels.</li>
</ol>
<h3>Mode [C]: Create a new modal DM, mapped to an existing DM using another loop's control modes</h3>
<p>In this mode, the AO loop controls a virtual DM. The virtual actuators are correspond to modes controlling the zero point offset of another loop. In this section, I assume that <b>loopA</b> is the main loop (directly controls a physical DM) and that <b>loopB</b> is the virtual loop (this is the loop we are setting up).</p>
<ol type="1">
<li>Select <b>MODAL</b> DM (<code>DMmodeZ</code> in <code>Top Menu</code> screen)</li>
<li>Set <b>DM number</b> (<code>S</code> command in <code>Top Menu</code> screen). This is the DM index for loopB.</li>
<li>Set <b>DM x size</b> to the number of modes of loop A to be addressed by loop B's virtual DM</li>
<li>Set <b>DM y size</b> to 1</li>
<li><b>Auto-configure: DM output linked to other loop</b> (<code>dmolink</code> in <code>Top Menu</code> screen).<ol type="a">
<li>choose loop index from which modes will be extracted (loop A index)</li>
<li>choose offset channel in output loop This will set up several key parameters and files:</li>
</ol>
<ul>
<li><b>DM-to-DM</b> mode will be set to 1, and associated streams:<ul>
<li><b>dm2dmM</b> : <b>loopA</b> modes controlled by <b>loopB</b></li>
<li><b>dm2dmO</b> : symbolic link to <b>loopA</b> DM channel controlled by <b>loopB</b></li>
</ul>
</li>
<li><b>CPU-based dmcomb output WFS ref</b> will be set to 1, and associated streams:<ul>
<li><b>dmwrefRM</b> : <b>loopA</b> WFS response to modes controlled by <b>loopB</b></li>
<li><b>dmwrefO</b> : <b>loopA</b> WFS zero point offset</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><b>OPTIONAL: set DM delay</b> ('setDMdelayON' and 'setDMdelayval' in <code>Top Menu</code> screen)</li>
</ul>
<ol type="1">
<li><b>Create the DM streams</b> with the <code>initDM</code> command in the <code>Top Menu</code>.</li>
<li><b>Load Memory</b> (<code>M</code> in <code>Top Menu</code> screen). The dm performs the symbolic links to the DM channels.</li>
</ol>
<h3>Mode [D]: Create a new modal DM, mapped to an existing DM channel using a custom set of modes</h3>
<p>In this mode, the AO loop controls a virtual DM. The virtual actuators correspond to modes controlling another DM stream. In this section, I assume that <b>loop A</b> is the main loop (directly controls a physical DM) and that <b>loop B</b> is the virtual (higher level) loop.</p>
<ol type="1">
<li>Choose DM index number (<code>S</code>) for loop B</li>
<li>Select number of loop A modes controlled by loop B. The number is entered as DM x size (<code>dmxs</code> in <code>Top menu</code>)</li>
<li>Enter 1 for DM y size (<code>dmys</code> in <code>Top menu</code>)</li>
<li>Set <b>DM-to-DM</b> mode to 1, and associated streams:<ul>
<li><b>dm2dmM</b> : loop A modes controlled by loop B</li>
<li><b>dm2dmO</b> : symbolic link to loop A DM channel controlled by loop B</li>
</ul>
</li>
<li>Set <b>CPU-based dmcomb output WFS ref</b> to 0 (see section below more enabling this option)</li>
<li>**(Re)-create DM streams and run DMcomb process** (<code>initDM</code>)</li>
<li><b>Load Memory</b> (<code>M</code> in <code>Top Menu</code> screen). The dm performs the symbolic links to the DM channels.</li>
</ol>
<p>Commands to the loop B DM should now propagate to modal commands to loop A.</p>
<h3>Option: WFS Zero point offset</h3>
<p>It is possible to add a zero point offset to mode D. Every write to the loop B's modal DM then generate both a write to loop A's DM (described above) and a write to the reference of a wavefront sensor (presumably loop A's wavefront sensor). This optional feature is refered to as a CPU-based WFS zero point offset.</p>
<p>To enable this feature, add between steps 4 and 5:</p>
<ol type="1">
<li>set <b>CPU-based dmcomb output WFS ref</b> to 1, and associated streams:<ul>
<li><b>dmwrefRM</b> : <b>loopA</b> WFS response to modes controlled by <b>loopB</b></li>
<li><b>dmwrefO</b> : <b>loopA</b> WFS zero point offset</li>
</ul>
</li>
</ol>
<h3>Notes</h3>
<p>You can (Re-)Start DM comb to re-initialize arrays and links ('stopDM' and 'initDM' commands in <code>Top Menu</code> screen). The <code>initDM</code> command will</p>
<ul>
<li>(re-)create shared memory streams dm##disp00 to dm##disp11</li>
<li>start the dmcomb process, which adds the dm##disp## channels to create the overall dm##disp displacement</li>
<li>create poke mask and maps</li>
</ul>
<h2>Setting the camera interface</h2>
<ul>
<li><b>link to WFS camera</b> (<code>wfs</code> to <code>Loop Configuration</code> screen). Select the WFS shared memory stream.</li>
</ul>
<h2>Setup script</h2>
<p>An <code>aosetup</code> script may be used to perform all these operations. Inspect the content of directory <code>aosetup</code> to see such scripts. You may use or modify as needed. If you use a <code>aosetup</code> script, execute it from the working directory, and then start aolconf:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./aosetup/aosetup_&lt;myLoop&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;./aolconf</div>
</div><!-- fragment --><h1>Calibration</h1>
<h2>Acquiring a zonal response matrix</h2>
<ul>
<li><b>set response matrix parameters</b> in <code>Loop Configure</code> screen: amplitude, time delay, frame averaging, excluded frames</li>
<li><b>set normalization and Hadmard modes</b> in <code>Loop Configure</code> screen. Normalization should probably be set to 1.</li>
<li><b>start zonal response matrix acquisition</b> (<code>zrespon</code> in <code>Loop Configure</code> screen). The process runs in tmux session aol::zrepM.</li>
<li><b>stop zonal response matrix acquistion</b> (<code>zrespoff</code> in <code>Loop Configure</code> screen).</li>
</ul>
<p>The following files are then created:</p>
<hr/>
<p> File Archived location Description </p><hr/>
<p> <b>zrespmat.fits</b> zrespM/zrespM_${datestr}.fits zonal response matrix</p>
<p><b>wfsref0.fits</b> wfsref0/wfsref0_${datestr}.fits WFS reference (time-averaged image)</p>
<p><b>wfsmap.fits</b> wfsmap/wfsmap_${datestr}.fits Map of WFS elements sensitivity</p>
<p><b>dmmap.fits</b> dmmap/dmmap_${datestr}.fits Map of DM elements sensitivity</p>
<p><b>wfsmask.fits</b> wfsmask/wfsmask_${datestr}.fits WFS pixel mask, derived from wfsmap</p>
<p><b>dmmaskRM.fits</b> dmmaskRM/dmmaskRM_${datestr}.fits DM actuator mask, derived from dmmap by selecting actuators with strong response</p>
<p><b>dmslaved.fits</b> dmslaved/dmslaved_${datestr}.fits slaved DM actuators: actuators near active actuators in dmmaskRM</p>
<p><b>dmmask.fits</b> dmmask/dmmask_${datestr}.fits DM mask: all actuators controlled (union of dmmaskRM and dmslaved) </p><hr/>
<p>Note that at this point, the files are NOT loaded in shared memory, but the archieved file names are stored in the staging area "conf_zrm_staged/conf_streamname.txt" for future loading.</p>
<ul>
<li><b>Adopt staged configuration</b> (<code>upzrm</code> in <code>Loop Configure</code> screen)</li>
<li><b>Load zrespm files into shared memory</b> (<code>SMloadzrm</code> in <code>Loop Configure</code> screen)</li>
</ul>
<h2>Acquiring a modal response matrix (optional, for ZONAL DM only)</h2>
<p>In addition to the zonal response matrix, a modal response matrix can be acquired to improve sensitivity to low-oder modes.</p>
<p>To do so:</p>
<ul>
<li>activate <code>RMMon</code> to <b>toggle the modal RM on</b>.</li>
<li><b>select RM amplitude and maximum cycles per aperture (CPA)</b></li>
<li><b>start the acquisiton</b> (<code>LOresp_on</code>)</li>
<li><b>stop the acquisiton</b> (<code>LOresp_off</code>)</li>
</ul>
<p>The following files are then created:</p>
<hr/>
<p> File Archived location Description </p><hr/>
<p> <b>LOrespmat.fits</b> LOrespM/LOrespM_${datestr}.fits Modal response matrix</p>
<p><b>respM_LOmodes.fits</b> LODMmodes/LODMmodes_${datestr}.fits Low-order modes</p>
<p><b>LOwfsref0.fits</b> LOwfsref0/LOwfsref0_${datestr}.fits WFS reference measured during LO RM acquisition</p>
<p><b>LOwfsmap.fits</b> LOwfsmap/LOwfsmap_${datestr}.fits Map of WFS elements sensitivity</p>
<p><b>LOdmmap.fits</b> LOdmmap/LOdmmap_${datestr}.fits Map of DM elements sensitivity</p>
<p><b>LOwfsmask.fits</b> LOwfsmask/LOwfsmask_${datestr}.fits WFS pixel mask, derived from wfsmap</p>
<p><b>LOdmmask.fits</b> LOdmmask/LOdmmask_${datestr}.fits DM actuator mask, derived from dmmap by selecting actuators with strong response </p><hr/>
<p>Note that at this point, the files are NOT loaded in shared memory, but the archieved file names are stored in the staging area "conf_mrm_staged//conf_streamname.txt" for future loading.</p>
<ul>
<li><b>Adopt staged configuration</b> (<code>upmrm</code> in <code>Loop Configure</code> screen)</li>
<li><b>Load LOrespm files into shared memory</b> (<code>SMloadmrm</code> in <code>Loop Configure</code> screen)</li>
</ul>
<h2>Automatic system calibration (recommended)</h2>
<p>The automatic system calibration performs all steps listed above under zonal and modal response matrix acquisition.</p>
<p>The old calibrations are archived as follows:</p>
<ul>
<li>"conf_zrm_staged" and "conf_mrm_staged" hold the new configuration (zonal and modal respectively)</li>
<li>"conf_zrm_staged.000" and "conf_mrm_staged.000" hold the previous configuration (previously "conf_zrm_staged" and "conf_mrm_staged")</li>
<li>"conf_zrm_staged.001" and "conf_mrm_staged.001" hold the configuration previously named "conf_zrm_staged.000" and "conf_mrm_staged.000"</li>
<li>etc for a total of 20 configuration</li>
</ul>
<h2>Managing configurations</h2>
<p>At any given time, the current configuration (including control matrices if they have been computed) can be saved using the <code>SAVE CURRENT SYSTEM CALIBRATION</code> command. Saving a configuration will save all files in the conf directory into a user-specified directory.</p>
<p>Previously saved configurations can be loaded with the <code>LOAD SAVED SYSTEM CALIBRATION</code> command. This will load saved files into the conf directory and load all files into shared memory.</p>
<h1>Building control matrix</h1>
<ul>
<li><b>set SVDlimit</b> (<code>SVDla</code> in <code>Control Matrix</code> screen). Set value is 0.1 as a starting point for a stable loop.</li>
<li><b>perform full CM computation</b> (<code>mkModes0</code> in <code>Control Matrix</code> screen). Enter first the number of CPA blocks you wish to use. Computation takes a few minutes, and takes place in tmux session <code>aol::mkmodes</code>.</li>
</ul>
<p>The following files are created:</p>
<hr/>
<p> File Archived location Description </p><hr/>
<p> <b>aolN_DMmodes</b> Mmodes/DMmodes_${datestr}.fits DM modes</p>
<p><b>aolN_respM</b> respM/respM_${datestr}.fits WFS response to DM modes </p><hr/>
<p>Block-specific files:</p>
<hr/>
<p> File Archived location Description </p><hr/>
<p> <b>aolN_DMmodesbb</b> DMmodes/DMmodesbb_${datestr}.fits DM modes for block bb</p>
<p><b>aolN_respMbb</b> respM/respMbb_${datestr}.fits WFS response to DM modes for block bb</p>
<p><b>aolN_contrMbb.fits</b> contrM/contrMbb_${datestr}.fits Control matrix for block bb</p>
<p><b>aolN_contrMcbb.fits</b> contrMc/contrMcbb_${datestr}.fits Collapsed control matrix for block bb</p>
<p><b>aolN_contrMcactbb.fits</b> contrMcact/contrMcactbb_${datestr}.fits Collabsed control matrix for block bb, only active actuators </p><hr/>
<p>Note that at this point, the files are NOT loaded in shared memory, but the archieved file names are stored in "conf/conf_&lt;streamname&gt;.txt" for future loading.</p>
<ul>
<li><b>Load CM files into shared memory</b> (<code>SMloadCM</code> in <code>Control Matrix</code> screen)</li>
</ul>
<h1>Running the loop: Choosing hardware mode (CPU/GPU)</h1>
<p>There are multiple ways to perform the computations on CPU and/or GPUs. The main 3 parameters are:</p>
<ul>
<li><b>GPU</b> : 0 if matrix multiplication(s) done on CPU, &gt;0 for GPU use. This is the number GPUs to use for matrix mult.</li>
<li><b>CMmode</b> : 1 if using a combined matrix between WFS pixels and DM actuators, skipping intermediate computation of modes</li>
<li><b>GPUall</b> : if using GPUall, then the WFS reference subtraction is wrapped inside the GPU matrix multiplication</li>
</ul>
<hr/>
<p> GPU CMmode GPUall Matrix Features Description </p><hr/>
<p> &gt;0 ON ON contrMcact fastest dark-subtracted WFS frame imWFS0 is multiplited by collapsed control matrix (only active pixels). no mcoeff normalization and WFS reference subtraction are wrapped in this GPU operation as subtraction of pre-computed vector output. This is the fastest mode.</p>
<p>&gt;0 ON OFF contrMcact WFS reference is subtracted from imWFS0 in CPU, yielding imWFS2. imWFS2 is multiplied by control matrix (only active pixels) in GPU.</p>
<p>&gt;0 OFF OFF contrM MWFS reference is subtracted from imWFS0 in CPU, yiedling imWFS2. imWFS2 is multiplied (GPU) by control matrix to yield mode values. Mode coefficients then multiplied (GPU) by modes.</p>
<p>0 ON - contrMcact imWFS2 is multiplied by control matrix (only active pixels) in CPU</p>
<p>0 OFF - contrM imWFS2 multiplied by modal control matrix </p><hr/>
<h1>Auxilliary processes</h1>
<p>A number of auxilliary processes can be running in addition to the main loop operation.</p>
<h2>Extract WFS modes</h2>
<p>Launches script <code>./auxscripts/modesextractwfs</code> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;!INCLUDE &quot;../scripts/auxscripts/modesextractwfs&quot;</div>
</div><!-- fragment --><p>Converts WFS residuals into modes.</p>
<h2>Extract open loop modes</h2>
<p>Launches script C function (CPU-based):</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;key       :    aolcompolm</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;module    :    AOloopControl.c</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;info      :    compute open loop mode values</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;syntax    :    &lt;loop #&gt;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;example   :    aolcompolm 2</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;C call    :    long AOloopControl_ComputeOpenLoopModes(long loop)</div>
</div><!-- fragment --><p>This function is entirely modal, and assumes that the WFS modes (see section above) are computed. The key input to the function is <code>aolN_modeval</code>, the WFS residual mode values. The function uses this telemetry and knowledge of loop gain and mult factor to track open loop mode values.</p>
<p>Optionally, it also includes <code>aolN_modeval_pC</code>, the predictive control mode values that are added to the correction in predictive mode.</p>
<h2>Running average of dmC</h2>
<p>Launches script <code>./auxscripts/aol_dmCave 0.0005</code> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;!INCLUDE &quot;../scripts/auxscripts/aol_dmCave&quot;</div>
</div><!-- fragment --><h2>Compute and average wfsres</h2>
<p>Launches script <code>./auxscripts/aolmkWFSres 0.0005</code> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;!INCLUDE &quot;../scripts/auxscripts/aolmkWFSres&quot;</div>
</div><!-- fragment --><h1>Offsetting</h1>
<h2>Overview</h2>
<p>Input channels are provided to offset the AO loop convergence point. By default, <b>DM channels 04, 05, 06, 07, and 08 are dedicated to zero-point offsetting</b>. The DM channels are sym-linked to <code>aolN_dmZP0</code> - <code>aolN_dmZP7</code>.</p>
<div class="image">
<img src="./figures/aoloopctr_offset.jpg"  alt="WFS zero point offsetting" title="WFS zero point offsetting"/>
</div>
<h2>DM offsets</h2>
<h3>Zonal CPU-based zero point offset</h3>
<p>CPU-based zero point offsets will compute WFS offsets from the zero point offset DM channels (04-11) and apply them to the <code>aolN_wfsref</code> stream. To activate this features, the user needs to :</p>
<ul>
<li><b>Toggle the zero point offset loop process ON</b> (<code>LPzpo</code>) prior to starting the loop.</li>
</ul>
<p>Cfits command <code>aolzpwfscloop</code> (C function <code>AOloopControl_WFSzeropoint_sum_update_loop</code>) launches a loop that monitors shared memory streams <code>aolN_wfszpo0</code> to <code>aolN_wfszpo3</code>, and updates the WFS reference when one of these has changed. The loop is running insite tmux session <code>aolNwfszpo</code>, and is launched when the loop is closed (<code>Floopon</code>) if the loop zero point offset flag is toggled on (<code>LPzpo</code>)</p>
<ul>
<li><b>Activate individual zero point offset channels</b> (<code>zplon0</code> to <code>zplon4</code>).</li>
</ul>
<p>Every time one of the activated DM channel changes, the corresponding wfs <code>aolN_wfszpo#</code> zero point offset is CPU-computed.</p>
<h3>GPU-based zero point offset</h3>
<p>A faster GPU-based zero point offset from DM to WFS is provided for each of the 8 offset channels. GPU-based and CPU-based offsetting for a single channel are mutually exclusive.</p>
<h2>WFS offsets</h2>
<h1>Controlling offsets from another loop</h1>
<h2>Running the loop</h2>
<p>The next steps are similar to the ones previously described, with the following important differences:</p>
<ul>
<li>The control matrix should be computed in zonal mode (no modal CPA block decomposition)</li>
</ul>
<h1>Predictive control (experimental)</h1>
<h2>Overview</h2>
<p>Predictive control is implemented in two processes:</p>
<ul>
<li>The optimal auto-regressive (AR) filter predicting the current state from previous states is computed. The AR filter is computed from open-loop estimates, so the processes computing open-loop telemetry need to be running.</li>
<li>the AR filter is applied to write a prediction buffer, which can be written asynchronously from the main loop steps.</li>
</ul>
<p>The predictive filter is modal, and adopts the same modes as the main control loop.</p>
<h2>Scripts</h2>
<hr/>
<p> File Description </p><hr/>
<p> <b>aolARPF</b> find auto-regressive predictive filter</p>
<p><b>aolARPFblock</b> AO find optimal AR linear predictive filter </p><hr/>
<h1>REFERENCE, ADDITIONAL PAGES</h1>
<ul>
<li>Page <a class="el" href="streams_semaphores.html">List of shared memory streams and semaphores</a></li>
<li>Page <a class="el" href="streams_semaphores.html">List of shared memory streams and semaphores</a></li>
<li>Page <a class="el" href="streams_semaphores.html">List of shared memory streams and semaphores</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jun 18 2017 00:36:59 for cfitsTK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
