#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <ctype.h>
#include <math.h>



#include "CLIcore.h"
#include "COREMOD_memory/COREMOD_memory.h"
#include "COREMOD_arith/COREMOD_arith.h"

#include "fft/fft.h"
#include "image_basic/image_basic.h"
#include "COREMOD_iofits/COREMOD_iofits.h"
#include "COREMOD_tools/COREMOD_tools.h"
#include "image_filter/image_filter.h"
#include "info/info.h"
#include "image_gen/image_gen.h"
#include "statistic/statistic.h"

#include "AtmosphericTurbulence/AtmosphericTurbulence.h"
#include "psf/psf.h"
#include "WFpropagate/WFpropagate.h"
#include "OpticsMaterials/OpticsMaterials.h"

#ifdef _OPENMP
#include <omp.h>
#endif



#define SWAP(x,y)  temp=(x);x=(y);y=temp;

#define PI 3.14159265358979323846264338328


extern DATA data;

char CONFFILE[200] = "WFsim.conf";
 
float SiteAlt;
float SiteTPW;
float SitePWSH;
float alpha1H2O;

// densities are in cm^-3
float *densN2;
float *densO;
float *densO2;
float *densHe;
float *densAr;
float *densN;
float *densO;
float *densH;
float *densH2O;
float *densCO2;
float *densNe;

float dens0;



/* -------------------------------------------------------------------- */
/* ---------  N R L M S I S E - 0 0    M O D E L    2 0 0 1  ---------- */
/* -------------------------------------------------------------------- */

/* This file is part of the NRLMSISE-00  C source code package - release
 * 20041227
 *
 * The NRLMSISE-00 model was developed by Mike Picone, Alan Hedin, and
 * Doug Drob. They also wrote a NRLMSISE-00 distribution package in 
 * FORTRAN which is available at
 * http://uap-www.nrl.navy.mil/models_web/msis/msis_home.htm
 *
 * Dominik Brodowski implemented and maintains this C version. You can
 * reach him at mail@brodo.de. See the file "DOCUMENTATION" for details,
 * and check http://www.brodo.de/english/pub/nrlmsise/index.html for
 * updated releases of this package.
 */



/* ------------------------------------------------------------------- */
/* --------------- ATMOSPHERIC MODEL VARIABLES ----------------------- */
/* ------------------------------------------------------------------- */

/* PARMB */
static double gsurf;
static double re;

/* GTS3C */
static double dd;

/* DMIX */
static double dm04, dm16, dm28, dm32, dm40, dm01, dm14;

/* MESO7 */
static double meso_tn1[5];
static double meso_tn2[4];
static double meso_tn3[5];
static double meso_tgn1[2];
static double meso_tgn2[2];
static double meso_tgn3[2];



/* ------------------------------------------------------------------- */
/* ------------------------ BLOCK DATA GTD7BK ------------------------ */
/* ------------------------------------------------------------------- */

/* TEMPERATURE */
double pt[150] = {
     9.86573E-01, 1.62228E-02, 1.55270E-02,-1.04323E-01,-3.75801E-03,
    -1.18538E-03,-1.24043E-01, 4.56820E-03, 8.76018E-03,-1.36235E-01,
    -3.52427E-02, 8.84181E-03,-5.92127E-03,-8.61650E+00, 0.00000E+00,
     1.28492E-02, 0.00000E+00, 1.30096E+02, 1.04567E-02, 1.65686E-03,
    -5.53887E-06, 2.97810E-03, 0.00000E+00, 5.13122E-03, 8.66784E-02,
     1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,-7.27026E-06,
     0.00000E+00, 6.74494E+00, 4.93933E-03, 2.21656E-03, 2.50802E-03,
     0.00000E+00, 0.00000E+00,-2.08841E-02,-1.79873E+00, 1.45103E-03,
     2.81769E-04,-1.44703E-03,-5.16394E-05, 8.47001E-02, 1.70147E-01,
     5.72562E-03, 5.07493E-05, 4.36148E-03, 1.17863E-04, 4.74364E-03,
     6.61278E-03, 4.34292E-05, 1.44373E-03, 2.41470E-05, 2.84426E-03,
     8.56560E-04, 2.04028E-03, 0.00000E+00,-3.15994E+03,-2.46423E-03,
     1.13843E-03, 4.20512E-04, 0.00000E+00,-9.77214E+01, 6.77794E-03,
     5.27499E-03, 1.14936E-03, 0.00000E+00,-6.61311E-03,-1.84255E-02,
    -1.96259E-02, 2.98618E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     6.44574E+02, 8.84668E-04, 5.05066E-04, 0.00000E+00, 4.02881E+03,
    -1.89503E-03, 0.00000E+00, 0.00000E+00, 8.21407E-04, 2.06780E-03,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -1.20410E-02,-3.63963E-03, 9.92070E-05,-1.15284E-04,-6.33059E-05,
    -6.05545E-01, 8.34218E-03,-9.13036E+01, 3.71042E-04, 0.00000E+00,
     4.19000E-04, 2.70928E-03, 3.31507E-03,-4.44508E-03,-4.96334E-03,
    -1.60449E-03, 3.95119E-03, 2.48924E-03, 5.09815E-04, 4.05302E-03,
     2.24076E-03, 0.00000E+00, 6.84256E-03, 4.66354E-04, 0.00000E+00,
    -3.68328E-04, 0.00000E+00, 0.00000E+00,-1.46870E+02, 0.00000E+00,
     0.00000E+00, 1.09501E-03, 4.65156E-04, 5.62583E-04, 3.21596E+00,
     6.43168E-04, 3.14860E-03, 3.40738E-03, 1.78481E-03, 9.62532E-04,
     5.58171E-04, 3.43731E+00,-2.33195E-01, 5.10289E-04, 0.00000E+00,
     0.00000E+00,-9.25347E+04, 0.00000E+00,-1.99639E-03, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
};


double pd[9][150] = {
/*  HE DENSITY */ {
     1.09979E+00,-4.88060E-02,-1.97501E-01,-9.10280E-02,-6.96558E-03,
     2.42136E-02, 3.91333E-01,-7.20068E-03,-3.22718E-02, 1.41508E+00,
     1.68194E-01, 1.85282E-02, 1.09384E-01,-7.24282E+00, 0.00000E+00,
     2.96377E-01,-4.97210E-02, 1.04114E+02,-8.61108E-02,-7.29177E-04,
     1.48998E-06, 1.08629E-03, 0.00000E+00, 0.00000E+00, 8.31090E-02,
     1.12818E-01,-5.75005E-02,-1.29919E-02,-1.78849E-02,-2.86343E-06,
     0.00000E+00,-1.51187E+02,-6.65902E-03, 0.00000E+00,-2.02069E-03,
     0.00000E+00, 0.00000E+00, 4.32264E-02,-2.80444E+01,-3.26789E-03,
     2.47461E-03, 0.00000E+00, 0.00000E+00, 9.82100E-02, 1.22714E-01,
    -3.96450E-02, 0.00000E+00,-2.76489E-03, 0.00000E+00, 1.87723E-03,
    -8.09813E-03, 4.34428E-05,-7.70932E-03, 0.00000E+00,-2.28894E-03,
    -5.69070E-03,-5.22193E-03, 6.00692E-03,-7.80434E+03,-3.48336E-03,
    -6.38362E-03,-1.82190E-03, 0.00000E+00,-7.58976E+01,-2.17875E-02,
    -1.72524E-02,-9.06287E-03, 0.00000E+00, 2.44725E-02, 8.66040E-02,
     1.05712E-01, 3.02543E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -6.01364E+03,-5.64668E-03,-2.54157E-03, 0.00000E+00, 3.15611E+02,
    -5.69158E-03, 0.00000E+00, 0.00000E+00,-4.47216E-03,-4.49523E-03,
     4.64428E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     4.51236E-02, 2.46520E-02, 6.17794E-03, 0.00000E+00, 0.00000E+00,
    -3.62944E-01,-4.80022E-02,-7.57230E+01,-1.99656E-03, 0.00000E+00,
    -5.18780E-03,-1.73990E-02,-9.03485E-03, 7.48465E-03, 1.53267E-02,
     1.06296E-02, 1.18655E-02, 2.55569E-03, 1.69020E-03, 3.51936E-02,
    -1.81242E-02, 0.00000E+00,-1.00529E-01,-5.10574E-03, 0.00000E+00,
     2.10228E-03, 0.00000E+00, 0.00000E+00,-1.73255E+02, 5.07833E-01,
    -2.41408E-01, 8.75414E-03, 2.77527E-03,-8.90353E-05,-5.25148E+00,
    -5.83899E-03,-2.09122E-02,-9.63530E-03, 9.77164E-03, 4.07051E-03,
     2.53555E-04,-5.52875E+00,-3.55993E-01,-2.49231E-03, 0.00000E+00,
     0.00000E+00, 2.86026E+01, 0.00000E+00, 3.42722E-04, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
}, /* O DENSITY */ {
     1.02315E+00,-1.59710E-01,-1.06630E-01,-1.77074E-02,-4.42726E-03,
     3.44803E-02, 4.45613E-02,-3.33751E-02,-5.73598E-02, 3.50360E-01,
     6.33053E-02, 2.16221E-02, 5.42577E-02,-5.74193E+00, 0.00000E+00,
     1.90891E-01,-1.39194E-02, 1.01102E+02, 8.16363E-02, 1.33717E-04,
     6.54403E-06, 3.10295E-03, 0.00000E+00, 0.00000E+00, 5.38205E-02,
     1.23910E-01,-1.39831E-02, 0.00000E+00, 0.00000E+00,-3.95915E-06,
     0.00000E+00,-7.14651E-01,-5.01027E-03, 0.00000E+00,-3.24756E-03,
     0.00000E+00, 0.00000E+00, 4.42173E-02,-1.31598E+01,-3.15626E-03,
     1.24574E-03,-1.47626E-03,-1.55461E-03, 6.40682E-02, 1.34898E-01,
    -2.42415E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 6.13666E-04,
    -5.40373E-03, 2.61635E-05,-3.33012E-03, 0.00000E+00,-3.08101E-03,
    -2.42679E-03,-3.36086E-03, 0.00000E+00,-1.18979E+03,-5.04738E-02,
    -2.61547E-03,-1.03132E-03, 1.91583E-04,-8.38132E+01,-1.40517E-02,
    -1.14167E-02,-4.08012E-03, 1.73522E-04,-1.39644E-02,-6.64128E-02,
    -6.85152E-02,-1.34414E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     6.07916E+02,-4.12220E-03,-2.20996E-03, 0.00000E+00, 1.70277E+03,
    -4.63015E-03, 0.00000E+00, 0.00000E+00,-2.25360E-03,-2.96204E-03,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     3.92786E-02, 1.31186E-02,-1.78086E-03, 0.00000E+00, 0.00000E+00,
    -3.90083E-01,-2.84741E-02,-7.78400E+01,-1.02601E-03, 0.00000E+00,
    -7.26485E-04,-5.42181E-03,-5.59305E-03, 1.22825E-02, 1.23868E-02,
     6.68835E-03,-1.03303E-02,-9.51903E-03, 2.70021E-04,-2.57084E-02,
    -1.32430E-02, 0.00000E+00,-3.81000E-02,-3.16810E-03, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-9.05762E-04,-2.14590E-03,-1.17824E-03, 3.66732E+00,
    -3.79729E-04,-6.13966E-03,-5.09082E-03,-1.96332E-03,-3.08280E-03,
    -9.75222E-04, 4.03315E+00,-2.52710E-01, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
}, /* N2 DENSITY */ {
     1.16112E+00, 0.00000E+00, 0.00000E+00, 3.33725E-02, 0.00000E+00,
     3.48637E-02,-5.44368E-03, 0.00000E+00,-6.73940E-02, 1.74754E-01,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 1.74712E+02, 0.00000E+00,
     1.26733E-01, 0.00000E+00, 1.03154E+02, 5.52075E-02, 0.00000E+00,
     0.00000E+00, 8.13525E-04, 0.00000E+00, 0.00000E+00, 8.66784E-02,
     1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-2.50482E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.48894E-03,
     6.16053E-04,-5.79716E-04, 2.95482E-03, 8.47001E-02, 1.70147E-01,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 2.47425E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
}, /* TLB */ {
     9.44846E-01, 0.00000E+00, 0.00000E+00,-3.08617E-02, 0.00000E+00,
    -2.44019E-02, 6.48607E-03, 0.00000E+00, 3.08181E-02, 4.59392E-02,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 1.74712E+02, 0.00000E+00,
     2.13260E-02, 0.00000E+00,-3.56958E+02, 0.00000E+00, 1.82278E-04,
     0.00000E+00, 3.07472E-04, 0.00000E+00, 0.00000E+00, 8.66784E-02,
     1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 3.83054E-03, 0.00000E+00, 0.00000E+00,
    -1.93065E-03,-1.45090E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-1.23493E-03, 1.36736E-03, 8.47001E-02, 1.70147E-01,
     3.71469E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     5.10250E-03, 2.47425E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 3.68756E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
}, /* O2 DENSITY */ {
     1.35580E+00, 1.44816E-01, 0.00000E+00, 6.07767E-02, 0.00000E+00,
     2.94777E-02, 7.46900E-02, 0.00000E+00,-9.23822E-02, 8.57342E-02,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 2.38636E+01, 0.00000E+00,
     7.71653E-02, 0.00000E+00, 8.18751E+01, 1.87736E-02, 0.00000E+00,
     0.00000E+00, 1.49667E-02, 0.00000E+00, 0.00000E+00, 8.66784E-02,
     1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-3.67874E+02, 5.48158E-03, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 8.47001E-02, 1.70147E-01,
     1.22631E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     8.17187E-03, 3.71617E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.10826E-03,
    -3.13640E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -7.35742E-02,-5.00266E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 1.94965E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
}, /* AR DENSITY */ {
     1.04761E+00, 2.00165E-01, 2.37697E-01, 3.68552E-02, 0.00000E+00,
     3.57202E-02,-2.14075E-01, 0.00000E+00,-1.08018E-01,-3.73981E-01,
     0.00000E+00, 3.10022E-02,-1.16305E-03,-2.07596E+01, 0.00000E+00,
     8.64502E-02, 0.00000E+00, 9.74908E+01, 5.16707E-02, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 8.66784E-02,
     1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 3.46193E+02, 1.34297E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-3.48509E-03,
    -1.54689E-04, 0.00000E+00, 0.00000E+00, 8.47001E-02, 1.70147E-01,
     1.47753E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     1.89320E-02, 3.68181E-05, 1.32570E-02, 0.00000E+00, 0.00000E+00,
     3.59719E-03, 7.44328E-03,-1.00023E-03,-6.50528E+03, 0.00000E+00,
     1.03485E-02,-1.00983E-03,-4.06916E-03,-6.60864E+01,-1.71533E-02,
     1.10605E-02, 1.20300E-02,-5.20034E-03, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -2.62769E+03, 7.13755E-03, 4.17999E-03, 0.00000E+00, 1.25910E+04,
     0.00000E+00, 0.00000E+00, 0.00000E+00,-2.23595E-03, 4.60217E-03,
     5.71794E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -3.18353E-02,-2.35526E-02,-1.36189E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 2.03522E-02,-6.67837E+01,-1.09724E-03, 0.00000E+00,
    -1.38821E-02, 1.60468E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.51574E-02,
    -5.44470E-04, 0.00000E+00, 7.28224E-02, 6.59413E-02, 0.00000E+00,
    -5.15692E-03, 0.00000E+00, 0.00000E+00,-3.70367E+03, 0.00000E+00,
     0.00000E+00, 1.36131E-02, 5.38153E-03, 0.00000E+00, 4.76285E+00,
    -1.75677E-02, 2.26301E-02, 0.00000E+00, 1.76631E-02, 4.77162E-03,
     0.00000E+00, 5.39354E+00, 0.00000E+00,-7.51710E-03, 0.00000E+00,
     0.00000E+00,-8.82736E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
}, /* H DENSITY */ {
     1.26376E+00,-2.14304E-01,-1.49984E-01, 2.30404E-01, 2.98237E-02,
     2.68673E-02, 2.96228E-01, 2.21900E-02,-2.07655E-02, 4.52506E-01,
     1.20105E-01, 3.24420E-02, 4.24816E-02,-9.14313E+00, 0.00000E+00,
     2.47178E-02,-2.88229E-02, 8.12805E+01, 5.10380E-02,-5.80611E-03,
     2.51236E-05,-1.24083E-02, 0.00000E+00, 0.00000E+00, 8.66784E-02,
     1.58727E-01,-3.48190E-02, 0.00000E+00, 0.00000E+00, 2.89885E-05,
     0.00000E+00, 1.53595E+02,-1.68604E-02, 0.00000E+00, 1.01015E-02,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.84552E-04,
    -1.22181E-03, 0.00000E+00, 0.00000E+00, 8.47001E-02, 1.70147E-01,
    -1.04927E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,-5.91313E-03,
    -2.30501E-02, 3.14758E-05, 0.00000E+00, 0.00000E+00, 1.26956E-02,
     8.35489E-03, 3.10513E-04, 0.00000E+00, 3.42119E+03,-2.45017E-03,
    -4.27154E-04, 5.45152E-04, 1.89896E-03, 2.89121E+01,-6.49973E-03,
    -1.93855E-02,-1.48492E-02, 0.00000E+00,-5.10576E-02, 7.87306E-02,
     9.51981E-02,-1.49422E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     2.65503E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 6.37110E-03, 3.24789E-04,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     6.14274E-02, 1.00376E-02,-8.41083E-04, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-1.27099E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -3.94077E-03,-1.28601E-02,-7.97616E-03, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-6.71465E-03,-1.69799E-03, 1.93772E-03, 3.81140E+00,
    -7.79290E-03,-1.82589E-02,-1.25860E-02,-1.04311E-02,-3.02465E-03,
     2.43063E-03, 3.63237E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
}, /* N DENSITY */ {
     7.09557E+01,-3.26740E-01, 0.00000E+00,-5.16829E-01,-1.71664E-03,
     9.09310E-02,-6.71500E-01,-1.47771E-01,-9.27471E-02,-2.30862E-01,
    -1.56410E-01, 1.34455E-02,-1.19717E-01, 2.52151E+00, 0.00000E+00,
    -2.41582E-01, 5.92939E-02, 4.39756E+00, 9.15280E-02, 4.41292E-03,
     0.00000E+00, 8.66807E-03, 0.00000E+00, 0.00000E+00, 8.66784E-02,
     1.58727E-01, 9.74701E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 6.70217E+01,-1.31660E-03, 0.00000E+00,-1.65317E-02,
     0.00000E+00, 0.00000E+00, 8.50247E-02, 2.77428E+01, 4.98658E-03,
     6.15115E-03, 9.50156E-03,-2.12723E-02, 8.47001E-02, 1.70147E-01,
    -2.38645E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.37380E-03,
    -8.41918E-03, 2.80145E-05, 7.12383E-03, 0.00000E+00,-1.66209E-02,
     1.03533E-04,-1.68898E-02, 0.00000E+00, 3.64526E+03, 0.00000E+00,
     6.54077E-03, 3.69130E-04, 9.94419E-04, 8.42803E+01,-1.16124E-02,
    -7.74414E-03,-1.68844E-03, 1.42809E-03,-1.92955E-03, 1.17225E-01,
    -2.41512E-02, 1.50521E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     1.60261E+03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00,-3.54403E-04,-1.87270E-02,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     2.76439E-02, 6.43207E-03,-3.54300E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-2.80221E-02, 8.11228E+01,-6.75255E-04, 0.00000E+00,
    -1.05162E-02,-3.48292E-03,-6.97321E-03, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-1.45546E-03,-1.31970E-02,-3.57751E-03,-1.09021E+00,
    -1.50181E-02,-7.12841E-03,-6.64590E-03,-3.52610E-03,-1.87773E-02,
    -2.22432E-03,-3.93895E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00 
}, /* HOT O DENSITY */ {
     6.04050E-02, 1.57034E+00, 2.99387E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-1.51018E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00,-8.61650E+00, 1.26454E-02,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 5.50878E-03, 0.00000E+00, 0.00000E+00, 8.66784E-02,
     1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 6.23881E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 8.47001E-02, 1.70147E-01,
    -9.45934E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
}};

/* S PARAM  */
double ps[150] = {
     9.56827E-01, 6.20637E-02, 3.18433E-02, 0.00000E+00, 0.00000E+00,
     3.94900E-02, 0.00000E+00, 0.00000E+00,-9.24882E-03,-7.94023E-03,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 1.74712E+02, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 2.74677E-03, 0.00000E+00, 1.54951E-02, 8.66784E-02,
     1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00,-6.99007E-04, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 1.24362E-02,-5.28756E-03, 8.47001E-02, 1.70147E-01,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 2.47425E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
};

/* TURBO */
double pdl[2][25] = {
   { 1.09930E+00, 3.90631E+00, 3.07165E+00, 9.86161E-01, 1.63536E+01,
     4.63830E+00, 1.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 1.28840E+00, 3.10302E-02, 1.18339E-01 }, 
   { 1.00000E+00, 7.00000E-01, 1.15020E+00, 3.44689E+00, 1.28840E+00,
     1.00000E+00, 1.08738E+00, 1.22947E+00, 1.10016E+00, 7.34129E-01,
     1.15241E+00, 2.22784E+00, 7.95046E-01, 4.01612E+00, 4.47749E+00,
     1.23435E+02,-7.60535E-02, 1.68986E-06, 7.44294E-01, 1.03604E+00,
     1.72783E+02, 1.15020E+00, 3.44689E+00,-7.46230E-01, 9.49154E-01 }
};

/* LOWER BOUNDARY */
double ptm[50] = {
     1.04130E+03, 3.86000E+02, 1.95000E+02, 1.66728E+01, 2.13000E+02,
     1.20000E+02, 2.40000E+02, 1.87000E+02,-2.00000E+00, 0.00000E+00
};
double pdm[8][10] = {
{    2.45600E+07, 6.71072E-06, 1.00000E+02, 0.00000E+00, 1.10000E+02,
     1.00000E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00 },\
{    8.59400E+10, 1.00000E+00, 1.05000E+02,-8.00000E+00, 1.10000E+02,
     1.00000E+01, 9.00000E+01, 2.00000E+00, 0.00000E+00, 0.00000E+00 },\
{    2.81000E+11, 0.00000E+00, 1.05000E+02, 2.80000E+01, 2.89500E+01,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00 },
{    3.30000E+10, 2.68270E-01, 1.05000E+02, 1.00000E+00, 1.10000E+02,
     1.00000E+01, 1.10000E+02,-1.00000E+01, 0.00000E+00, 0.00000E+00 },
{    1.33000E+09, 1.19615E-02, 1.05000E+02, 0.00000E+00, 1.10000E+02,
     1.00000E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00 },
{    1.76100E+05, 1.00000E+00, 9.50000E+01,-8.00000E+00, 1.10000E+02,
     1.00000E+01, 9.00000E+01, 2.00000E+00, 0.00000E+00, 0.00000E+00, },
{    1.00000E+07, 1.00000E+00, 1.05000E+02,-8.00000E+00, 1.10000E+02,
     1.00000E+01, 9.00000E+01, 2.00000E+00, 0.00000E+00, 0.00000E+00 },
{    1.00000E+06, 1.00000E+00, 1.05000E+02,-8.00000E+00, 5.50000E+02,
     7.60000E+01, 9.00000E+01, 2.00000E+00, 0.00000E+00, 4.00000E+03 }};


double ptl[4][100] = {
/* TN1(2) */ {
     1.00858E+00, 4.56011E-02,-2.22972E-02,-5.44388E-02, 5.23136E-04,
    -1.88849E-02, 5.23707E-02,-9.43646E-03, 6.31707E-03,-7.80460E-02,
    -4.88430E-02, 0.00000E+00, 0.00000E+00,-7.60250E+00, 0.00000E+00,
    -1.44635E-02,-1.76843E-02,-1.21517E+02, 2.85647E-02, 0.00000E+00,
     0.00000E+00, 6.31792E-04, 0.00000E+00, 5.77197E-03, 8.66784E-02,
     1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-8.90272E+03, 3.30611E-03, 3.02172E-03, 0.00000E+00,
    -2.13673E-03,-3.20910E-04, 0.00000E+00, 0.00000E+00, 2.76034E-03,
     2.82487E-03,-2.97592E-04,-4.21534E-03, 8.47001E-02, 1.70147E-01,
     8.96456E-03, 0.00000E+00,-1.08596E-02, 0.00000E+00, 0.00000E+00,
     5.57917E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 9.65405E-03, 0.00000E+00, 0.00000E+00, 2.00000E+00
}, /*  TN1(3) */ {
     9.39664E-01, 8.56514E-02,-6.79989E-03, 2.65929E-02,-4.74283E-03,
     1.21855E-02,-2.14905E-02, 6.49651E-03,-2.05477E-02,-4.24952E-02,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 1.19148E+01, 0.00000E+00,
     1.18777E-02,-7.28230E-02,-8.15965E+01, 1.73887E-02, 0.00000E+00,
     0.00000E+00, 0.00000E+00,-1.44691E-02, 2.80259E-04, 8.66784E-02,
     1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 2.16584E+02, 3.18713E-03, 7.37479E-03, 0.00000E+00,
    -2.55018E-03,-3.92806E-03, 0.00000E+00, 0.00000E+00,-2.89757E-03,
    -1.33549E-03, 1.02661E-03, 3.53775E-04, 8.47001E-02, 1.70147E-01,
    -9.17497E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     3.56082E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-1.00902E-02, 0.00000E+00, 0.00000E+00, 2.00000E+00
}, /* TN1(4) */ {
     9.85982E-01,-4.55435E-02, 1.21106E-02, 2.04127E-02,-2.40836E-03,
     1.11383E-02,-4.51926E-02, 1.35074E-02,-6.54139E-03, 1.15275E-01,
     1.28247E-01, 0.00000E+00, 0.00000E+00,-5.30705E+00, 0.00000E+00,
    -3.79332E-02,-6.24741E-02, 7.71062E-01, 2.96315E-02, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 6.81051E-03,-4.34767E-03, 8.66784E-02,
     1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 1.07003E+01,-2.76907E-03, 4.32474E-04, 0.00000E+00,
     1.31497E-03,-6.47517E-04, 0.00000E+00,-2.20621E+01,-1.10804E-03,
    -8.09338E-04, 4.18184E-04, 4.29650E-03, 8.47001E-02, 1.70147E-01,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -4.04337E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-9.52550E-04,
     8.56253E-04, 4.33114E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.21223E-03,
     2.38694E-04, 9.15245E-04, 1.28385E-03, 8.67668E-04,-5.61425E-06,
     1.04445E+00, 3.41112E+01, 0.00000E+00,-8.40704E-01,-2.39639E+02,
     7.06668E-01,-2.05873E+01,-3.63696E-01, 2.39245E+01, 0.00000E+00,
    -1.06657E-03,-7.67292E-04, 1.54534E-04, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
}, /* TN1(5) TN2(1) */ {
     1.00320E+00, 3.83501E-02,-2.38983E-03, 2.83950E-03, 4.20956E-03,
     5.86619E-04, 2.19054E-02,-1.00946E-02,-3.50259E-03, 4.17392E-02,
    -8.44404E-03, 0.00000E+00, 0.00000E+00, 4.96949E+00, 0.00000E+00,
    -7.06478E-03,-1.46494E-02, 3.13258E+01,-1.86493E-03, 0.00000E+00,
    -1.67499E-02, 0.00000E+00, 0.00000E+00, 5.12686E-04, 8.66784E-02,
     1.58727E-01,-4.64167E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     4.37353E-03,-1.99069E+02, 0.00000E+00,-5.34884E-03, 0.00000E+00,
     1.62458E-03, 2.93016E-03, 2.67926E-03, 5.90449E+02, 0.00000E+00,
     0.00000E+00,-1.17266E-03,-3.58890E-04, 8.47001E-02, 1.70147E-01,
     0.00000E+00, 0.00000E+00, 1.38673E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.60571E-03,
     6.28078E-04, 5.05469E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-1.57829E-03,
    -4.00855E-04, 5.04077E-05,-1.39001E-03,-2.33406E-03,-4.81197E-04,
     1.46758E+00, 6.20332E+00, 0.00000E+00, 3.66476E-01,-6.19760E+01,
     3.09198E-01,-1.98999E+01, 0.00000E+00,-3.29933E+02, 0.00000E+00,
    -1.10080E-03,-9.39310E-05, 1.39638E-04, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
} };

double pma[10][100] = {
/* TN2(2) */ {
     9.81637E-01,-1.41317E-03, 3.87323E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-3.58707E-02,
    -8.63658E-03, 0.00000E+00, 0.00000E+00,-2.02226E+00, 0.00000E+00,
    -8.69424E-03,-1.91397E-02, 8.76779E+01, 4.52188E-03, 0.00000E+00,
     2.23760E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-7.07572E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -4.11210E-03, 3.50060E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00,-8.36657E-03, 1.61347E+01, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00,-1.45130E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.24152E-03,
     6.43365E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.33255E-03,
     2.42657E-03, 1.60666E-03,-1.85728E-03,-1.46874E-03,-4.79163E-06,
     1.22464E+00, 3.53510E+01, 0.00000E+00, 4.49223E-01,-4.77466E+01,
     4.70681E-01, 8.41861E+00,-2.88198E-01, 1.67854E+02, 0.00000E+00,
     7.11493E-04, 6.05601E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
}, /* TN2(3) */ {
     1.00422E+00,-7.11212E-03, 5.24480E-03, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-5.28914E-02,
    -2.41301E-02, 0.00000E+00, 0.00000E+00,-2.12219E+01,-1.03830E-02,
    -3.28077E-03, 1.65727E-02, 1.68564E+00,-6.68154E-03, 0.00000E+00,
     1.45155E-02, 0.00000E+00, 8.42365E-03, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-4.34645E-03, 0.00000E+00, 0.00000E+00, 2.16780E-02,
     0.00000E+00,-1.38459E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 7.04573E-03,-4.73204E+01, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 1.08767E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-8.08279E-03,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 5.21769E-04,
    -2.27387E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.26769E-03,
     3.16901E-03, 4.60316E-04,-1.01431E-04, 1.02131E-03, 9.96601E-04,
     1.25707E+00, 2.50114E+01, 0.00000E+00, 4.24472E-01,-2.77655E+01,
     3.44625E-01, 2.75412E+01, 0.00000E+00, 7.94251E+02, 0.00000E+00,
     2.45835E-03, 1.38871E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
}, /* TN2(4) TN3(1) */ {
     1.01890E+00,-2.46603E-02, 1.00078E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-6.70977E-02,
    -4.02286E-02, 0.00000E+00, 0.00000E+00,-2.29466E+01,-7.47019E-03,
     2.26580E-03, 2.63931E-02, 3.72625E+01,-6.39041E-03, 0.00000E+00,
     9.58383E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-1.85291E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 1.39717E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 9.19771E-03,-3.69121E+02, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00,-1.57067E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-7.07265E-03,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.92953E-03,
    -2.77739E-03,-4.40092E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.47280E-03,
     2.95035E-04,-1.81246E-03, 2.81945E-03, 4.27296E-03, 9.78863E-04,
     1.40545E+00,-6.19173E+00, 0.00000E+00, 0.00000E+00,-7.93632E+01,
     4.44643E-01,-4.03085E+02, 0.00000E+00, 1.15603E+01, 0.00000E+00,
     2.25068E-03, 8.48557E-04,-2.98493E-04, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
}, /* TN3(2) */ {
     9.75801E-01, 3.80680E-02,-3.05198E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.85575E-02,
     5.04057E-02, 0.00000E+00, 0.00000E+00,-1.76046E+02, 1.44594E-02,
    -1.48297E-03,-3.68560E-03, 3.02185E+01,-3.23338E-03, 0.00000E+00,
     1.53569E-02, 0.00000E+00,-1.15558E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 4.89620E-03, 0.00000E+00, 0.00000E+00,-1.00616E-02,
    -8.21324E-03,-1.57757E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 6.63564E-03, 4.58410E+01, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00,-2.51280E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 9.91215E-03,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-8.73148E-04,
    -1.29648E-03,-7.32026E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-4.68110E-03,
    -4.66003E-03,-1.31567E-03,-7.39390E-04, 6.32499E-04,-4.65588E-04,
    -1.29785E+00,-1.57139E+02, 0.00000E+00, 2.58350E-01,-3.69453E+01,
     4.10672E-01, 9.78196E+00,-1.52064E-01,-3.85084E+03, 0.00000E+00,
    -8.52706E-04,-1.40945E-03,-7.26786E-04, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
}, /* TN3(3) */ {
     9.60722E-01, 7.03757E-02,-3.00266E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.22671E-02,
     4.10423E-02, 0.00000E+00, 0.00000E+00,-1.63070E+02, 1.06073E-02,
     5.40747E-04, 7.79481E-03, 1.44908E+02, 1.51484E-04, 0.00000E+00,
     1.97547E-02, 0.00000E+00,-1.41844E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 5.77884E-03, 0.00000E+00, 0.00000E+00, 9.74319E-03,
     0.00000E+00,-2.88015E+03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00,-4.44902E-03,-2.92760E+01, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 2.34419E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 5.36685E-03,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-4.65325E-04,
    -5.50628E-04, 3.31465E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.06179E-03,
    -3.08575E-03,-7.93589E-04,-1.08629E-04, 5.95511E-04,-9.05050E-04,
     1.18997E+00, 4.15924E+01, 0.00000E+00,-4.72064E-01,-9.47150E+02,
     3.98723E-01, 1.98304E+01, 0.00000E+00, 3.73219E+03, 0.00000E+00,
    -1.50040E-03,-1.14933E-03,-1.56769E-04, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
}, /* TN3(4) */ {
     1.03123E+00,-7.05124E-02, 8.71615E-03, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-3.82621E-02,
    -9.80975E-03, 0.00000E+00, 0.00000E+00, 2.89286E+01, 9.57341E-03,
     0.00000E+00, 0.00000E+00, 8.66153E+01, 7.91938E-04, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 4.68917E-03, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 7.86638E-03, 0.00000E+00, 0.00000E+00, 9.90827E-03,
     0.00000E+00, 6.55573E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00,-4.00200E+01, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 7.07457E-03, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 5.72268E-03,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.04970E-04,
     1.21560E-03,-8.05579E-06, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.49941E-03,
    -4.57256E-04,-1.59311E-04, 2.96481E-04,-1.77318E-03,-6.37918E-04,
     1.02395E+00, 1.28172E+01, 0.00000E+00, 1.49903E-01,-2.63818E+01,
     0.00000E+00, 4.70628E+01,-2.22139E-01, 4.82292E-02, 0.00000E+00,
    -8.67075E-04,-5.86479E-04, 5.32462E-04, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
}, /* TN3(5) SURFACE TEMP TSL */ {
     1.00828E+00,-9.10404E-02,-2.26549E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.32420E-02,
    -9.08925E-03, 0.00000E+00, 0.00000E+00, 3.36105E+01, 0.00000E+00,
     0.00000E+00, 0.00000E+00,-1.24957E+01,-5.87939E-03, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 2.79765E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 2.01237E+03, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00,-1.75553E-02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.29699E-03,
     1.26659E-03, 2.68402E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.17894E-03,
     1.48746E-03, 1.06478E-04, 1.34743E-04,-2.20939E-03,-6.23523E-04,
     6.36539E-01, 1.13621E+01, 0.00000E+00,-3.93777E-01, 2.38687E+03,
     0.00000E+00, 6.61865E+02,-1.21434E-01, 9.27608E+00, 0.00000E+00,
     1.68478E-04, 1.24892E-03, 1.71345E-03, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
}, /* TGN3(2) SURFACE GRAD TSLG */ {
     1.57293E+00,-6.78400E-01, 6.47500E-01, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-7.62974E-02,
    -3.60423E-01, 0.00000E+00, 0.00000E+00, 1.28358E+02, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 4.68038E+01, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-1.67898E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 2.90994E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 3.15706E+01, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
}, /* TGN2(1) TGN1(2) */ {
     8.60028E-01, 3.77052E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-1.17570E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 7.77757E-03, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 1.01024E+02, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 6.54251E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-1.56959E-02,
     1.91001E-02, 3.15971E-02, 1.00982E-02,-6.71565E-03, 2.57693E-03,
     1.38692E+00, 2.82132E-01, 0.00000E+00, 0.00000E+00, 3.81511E+02,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
}, /* TGN3(1) TGN2(2) */ {
     1.06029E+00,-5.25231E-02, 3.73034E-01, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.31072E-02,
    -3.88409E-01, 0.00000E+00, 0.00000E+00,-1.65295E+02,-2.13801E-01,
    -4.38916E-02,-3.22716E-01,-8.82393E+01, 1.18458E-01, 0.00000E+00,
    -4.35863E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00,-1.19782E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 2.62229E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00,-5.37443E+01, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00,-4.55788E-01, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.84009E-02,
     3.96733E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 5.05494E-02,
     7.39617E-02, 1.92200E-02,-8.46151E-03,-1.34244E-02, 1.96338E-02,
     1.50421E+00, 1.88368E+01, 0.00000E+00, 0.00000E+00,-5.13114E+01,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     5.11923E-02, 3.61225E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
} };
 
/* SEMIANNUAL MULT SAM */
double sam[100] = {
     1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
     1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
     1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
     1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
     1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
     1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
     1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
     1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
     1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
     1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
};
 


/* MIDDLE ATMOSPHERE AVERAGES */
double pavgm[10] = {
     2.61000E+02, 2.64000E+02, 2.29000E+02, 2.17000E+02, 2.17000E+02,
     2.23000E+02, 2.86760E+02,-2.93940E+00, 2.50000E+00, 0.00000E+00 };
 

 

double ptl[4][100];


/* LPOLY */
static double dfa;
static double plg[4][9];
static double ctloc, stloc;
static double c2tloc, s2tloc;
static double s3tloc, c3tloc;
static double apdf, apt[4];


























// CLI commands
//
// function CLI_checkarg used to check arguments
// 1: float
// 2: long
// 3: string
// 4: existing image
//


int make_AtmosphericTurbulence_wavefront_series_cli()
{
  make_AtmosphericTurbulence_wavefront_series();

  return 0;
}




int AtmosphericTurbulence_mkmastert_cli()
{
  
  if(CLI_checkarg(1,3)+CLI_checkarg(2,3)+CLI_checkarg(3,2)+CLI_checkarg(4,1)+CLI_checkarg(5,1)==0)
    {
      make_master_turbulence_screen(data.cmdargtoken[1].val.string, data.cmdargtoken[2].val.string, data.cmdargtoken[3].val.numl, 1.0*data.cmdargtoken[4].val.numf, 1.0*data.cmdargtoken[5].val.numf);
    }
  else
    return 1;
}





int init_AtmosphericTurbulence()
{
  strcpy(data.module[data.NBmodule].name, __FILE__);
  strcpy(data.module[data.NBmodule].info, "Atmospheric Turbulence");
  data.NBmodule++;


  strcpy(data.cmd[data.NBcmd].key,"mkwfs");
  strcpy(data.cmd[data.NBcmd].module,__FILE__);
  data.cmd[data.NBcmd].fp = make_AtmosphericTurbulence_wavefront_series_cli;
  strcpy(data.cmd[data.NBcmd].info,"make wavefront series");
  strcpy(data.cmd[data.NBcmd].syntax,"no arguments");
  strcpy(data.cmd[data.NBcmd].example,"mkwfs");
  strcpy(data.cmd[data.NBcmd].Ccall,"int make_AtmosphericTurbulence_wavefront_series()");
  data.NBcmd++;


  strcpy(data.cmd[data.NBcmd].key,"mkmastert");
  strcpy(data.cmd[data.NBcmd].module,__FILE__);
  data.cmd[data.NBcmd].fp = AtmosphericTurbulence_mkmastert_cli;
  strcpy(data.cmd[data.NBcmd].info,"make 2 master phase screens");
  strcpy(data.cmd[data.NBcmd].syntax,"<screen0> <screen1> <size> <outerscale> <innerscale>");
  strcpy(data.cmd[data.NBcmd].example,"mkmastert scr0 scr1 2048 50.0 2.0");
  strcpy(data.cmd[data.NBcmd].Ccall,"int make_master_turbulence_screen(char *ID_name1, char *ID_name2, long size, float outercale, float innercale)");
  data.NBcmd++;

  return 0;
}

























/* ------------------------------------------------------------------- */
/* ------------------------------ TSELEC ----------------------------- */
/* ------------------------------------------------------------------- */

void tselec(struct nrlmsise_flags *flags) {
	int i;
	for (i=0;i<24;i++) {
		if (i!=9) {
			if (flags->switches[i]==1)
				flags->sw[i]=1;
			else
				flags->sw[i]=0;
			if (flags->switches[i]>0)
				flags->swc[i]=1;
			else
				flags->swc[i]=0;
		} else {
			flags->sw[i]=flags->switches[i];
			flags->swc[i]=flags->switches[i];
		}
	}
}



/* ------------------------------------------------------------------- */
/* ------------------------------ GLATF ------------------------------ */
/* ------------------------------------------------------------------- */

void glatf(double lat, double *gv, double *reff) {
	double dgtr = 1.74533E-2;
	double c2;
	c2 = cos(2.0*dgtr*lat);
	*gv = 980.616 * (1.0 - 0.0026373 * c2);
	*reff = 2.0 * (*gv) / (3.085462E-6 + 2.27E-9 * c2) * 1.0E-5;
}



/* ------------------------------------------------------------------- */
/* ------------------------------ CCOR ------------------------------- */
/* ------------------------------------------------------------------- */

double ccor(double alt, double r, double h1, double zh) {
/*        CHEMISTRY/DISSOCIATION CORRECTION FOR MSIS MODELS
 *         ALT - altitude
 *         R - target ratio
 *         H1 - transition scale length
 *         ZH - altitude of 1/2 R
 */
	double e;
	double ex;
	e = (alt - zh) / h1;
	if (e>70)
		return exp(0);
	if (e<-70)
		return exp(r);
	ex = exp(e);
	e = r / (1.0 + ex);
	return exp(e);
}



/* ------------------------------------------------------------------- */
/* ------------------------------ CCOR ------------------------------- */
/* ------------------------------------------------------------------- */

double ccor2(double alt, double r, double h1, double zh, double h2) {
/*        CHEMISTRY/DISSOCIATION CORRECTION FOR MSIS MODELS
 *         ALT - altitude
 *         R - target ratio
 *         H1 - transition scale length
 *         ZH - altitude of 1/2 R
 *         H2 - transition scale length #2 ?
 */
	double e1, e2;
	double ex1, ex2;
	double ccor2v;
	e1 = (alt - zh) / h1;
	e2 = (alt - zh) / h2;
	if ((e1 > 70) || (e2 > 70))
		return exp(0);
	if ((e1 < -70) && (e2 < -70))
		return exp(r);
	ex1 = exp(e1);
	ex2 = exp(e2);
	ccor2v = r / (1.0 + 0.5 * (ex1 + ex2));
	return exp(ccor2v);
}



/* ------------------------------------------------------------------- */
/* ------------------------------- SCALH ----------------------------- */
/* ------------------------------------------------------------------- */

double scalh(double alt, double xm, double temp) {
	double g;
	double rgas=831.4;
	g = gsurf / (pow((1.0 + alt/re),2.0));
	g = rgas * temp / (g * xm);
	return g;
}



/* ------------------------------------------------------------------- */
/* -------------------------------- DNET ----------------------------- */
/* ------------------------------------------------------------------- */

double dnet (double dd, double dm, double zhm, double xmm, double xm) {
/*       TURBOPAUSE CORRECTION FOR MSIS MODELS
 *        Root mean density
 *         DD - diffusive density
 *         DM - full mixed density
 *         ZHM - transition scale length
 *         XMM - full mixed molecular weight
 *         XM  - species molecular weight
 *         DNET - combined density
 */
	double a;
	double ylog;
	a  = zhm / (xmm-xm);
	if (!((dm>0) && (dd>0))) {
		printf("dnet log error %e %e %e\n",dm,dd,xm);
		if ((dd==0) && (dm==0))
			dd=1;
		if (dm==0)
			return dd;
		if (dd==0)
			return dm;
	} 
	ylog = a * log(dm/dd);
	if (ylog<-10)
		return dd;
	if (ylog>10)
		return dm;
	a = dd*pow((1.0 + exp(ylog)),(1.0/a));
	return a;
}



/* ------------------------------------------------------------------- */
/* ------------------------------- SPLINI ---------------------------- */
/* ------------------------------------------------------------------- */

void splini (double *xa, double *ya, double *y2a, int n, double x, double *y) {
/*      INTEGRATE CUBIC SPLINE FUNCTION FROM XA(1) TO X
 *       XA,YA: ARRAYS OF TABULATED FUNCTION IN ASCENDING ORDER BY X
 *       Y2A: ARRAY OF SECOND DERIVATIVES
 *       N: SIZE OF ARRAYS XA,YA,Y2A
 *       X: ABSCISSA ENDPOINT FOR INTEGRATION
 *       Y: OUTPUT VALUE
 */
	double yi=0;
	int klo=0;
	int khi=1;
	double xx, h, a, b, a2, b2;
	while ((x>xa[klo]) && (khi<n)) {
		xx=x;
		if (khi<(n-1)) {
			if (x<xa[khi])
				xx=x;
			else 
				xx=xa[khi];
		}
		h = xa[khi] - xa[klo];
		a = (xa[khi] - xx)/h;
		b = (xx - xa[klo])/h;
		a2 = a*a;
		b2 = b*b;
		yi += ((1.0 - a2) * ya[klo] / 2.0 + b2 * ya[khi] / 2.0 + ((-(1.0+a2*a2)/4.0 + a2/2.0) * y2a[klo] + (b2*b2/4.0 - b2/2.0) * y2a[khi]) * h * h / 6.0) * h;
		klo++;
		khi++;
	}
	*y = yi;
}



/* ------------------------------------------------------------------- */
/* ------------------------------- SPLINT ---------------------------- */
/* ------------------------------------------------------------------- */

void splint (double *xa, double *ya, double *y2a, int n, double x, double *y) {
/*      CALCULATE CUBIC SPLINE INTERP VALUE
 *       ADAPTED FROM NUMERICAL RECIPES BY PRESS ET AL.
 *       XA,YA: ARRAYS OF TABULATED FUNCTION IN ASCENDING ORDER BY X
 *       Y2A: ARRAY OF SECOND DERIVATIVES
 *       N: SIZE OF ARRAYS XA,YA,Y2A
 *       X: ABSCISSA FOR INTERPOLATION
 *       Y: OUTPUT VALUE
 */
	int klo=0;
	int khi=n-1;
	int k;
	double h;
	double a, b, yi;
	while ((khi-klo)>1) {
		k=(khi+klo)/2;
		if (xa[k]>x)
			khi=k;
		else
			klo=k;
	}
	h = xa[khi] - xa[klo];
	if (h==0.0)
		printf("bad XA input to splint");
	a = (xa[khi] - x)/h;
	b = (x - xa[klo])/h;
	yi = a * ya[klo] + b * ya[khi] + ((a*a*a - a) * y2a[klo] + (b*b*b - b) * y2a[khi]) * h * h/6.0;
	*y = yi;
}



/* ------------------------------------------------------------------- */
/* ------------------------------- SPLINE ---------------------------- */
/* ------------------------------------------------------------------- */

void spline (double *x, double *y, int n, double yp1, double ypn, double *y2) {
/*       CALCULATE 2ND DERIVATIVES OF CUBIC SPLINE INTERP FUNCTION
 *       ADAPTED FROM NUMERICAL RECIPES BY PRESS ET AL
 *       X,Y: ARRAYS OF TABULATED FUNCTION IN ASCENDING ORDER BY X
 *       N: SIZE OF ARRAYS X,Y
 *       YP1,YPN: SPECIFIED DERIVATIVES AT X[0] AND X[N-1]; VALUES
 *                >= 1E30 SIGNAL SIGNAL SECOND DERIVATIVE ZERO
 *       Y2: OUTPUT ARRAY OF SECOND DERIVATIVES
 */
	double *u;
	double sig, p, qn, un;
	int i, k;
	u=malloc(sizeof(double)*(unsigned int)n);
	if (u==NULL) {
		printf("Out Of Memory in spline - ERROR");
		return;
	}
	if (yp1>0.99E30) {
		y2[0]=0;
		u[0]=0;
	} else {
		y2[0]=-0.5;
		u[0]=(3.0/(x[1]-x[0]))*((y[1]-y[0])/(x[1]-x[0])-yp1);
	}
	for (i=1;i<(n-1);i++) {
		sig = (x[i]-x[i-1])/(x[i+1] - x[i-1]);
		p = sig * y2[i-1] + 2.0;
		y2[i] = (sig - 1.0) / p;
		u[i] = (6.0 * ((y[i+1] - y[i])/(x[i+1] - x[i]) -(y[i] - y[i-1]) / (x[i] - x[i-1]))/(x[i+1] - x[i-1]) - sig * u[i-1])/p;
	}
	if (ypn>0.99E30) {
		qn = 0;
		un = 0;
	} else {
		qn = 0.5;
		un = (3.0 / (x[n-1] - x[n-2])) * (ypn - (y[n-1] - y[n-2])/(x[n-1] - x[n-2]));
	}
	y2[n-1] = (un - qn * u[n-2]) / (qn * y2[n-2] + 1.0);
	for (k=n-2;k>=0;k--)
		y2[k] = y2[k] * y2[k+1] + u[k];

	free(u);
}



/* ------------------------------------------------------------------- */
/* ------------------------------- DENSM ----------------------------- */
/* ------------------------------------------------------------------- */

__inline_double zeta(double zz, double zl) {
	return ((zz-zl)*(re+zl)/(re+zz));
}

double densm (double alt, double d0, double xm, double *tz, int mn3, double *zn3, double *tn3, double *tgn3, int mn2, double *zn2, double *tn2, double *tgn2) {
/*      Calculate Temperature and Density Profiles for lower atmos.  */
	double xs[10], ys[10], y2out[10];
	double rgas = 831.4;
	double z, z1, z2, t1, t2, zg, zgdif;
	double yd1, yd2;
	double x, y, yi;
	double expl, gamm, glb;
	double densm_tmp;
	int mn;
	int k;
	densm_tmp=d0;
	if (alt>zn2[0]) {
		if (xm==0.0)
			return *tz;
		else
			return d0;
	}

	/* STRATOSPHERE/MESOSPHERE TEMPERATURE */
	if (alt>zn2[mn2-1])
		z=alt;
	else
		z=zn2[mn2-1];
	mn=mn2;
	z1=zn2[0];
	z2=zn2[mn-1];
	t1=tn2[0];
	t2=tn2[mn-1];
	zg = zeta(z, z1);
	zgdif = zeta(z2, z1);

	/* set up spline nodes */
	for (k=0;k<mn;k++) {
		xs[k]=zeta(zn2[k],z1)/zgdif;
		ys[k]=1.0 / tn2[k];
	}
	yd1=-tgn2[0] / (t1*t1) * zgdif;
	yd2=-tgn2[1] / (t2*t2) * zgdif * (pow(((re+z2)/(re+z1)),2.0));

	/* calculate spline coefficients */
	spline (xs, ys, mn, yd1, yd2, y2out);
	x = zg/zgdif;
	splint (xs, ys, y2out, mn, x, &y);

	/* temperature at altitude */
	*tz = 1.0 / y;
	if (xm!=0.0) {
		/* calaculate stratosphere / mesospehere density */
		glb = gsurf / (pow((1.0 + z1/re),2.0));
		gamm = xm * glb * zgdif / rgas;

		/* Integrate temperature profile */
		splini(xs, ys, y2out, mn, x, &yi);
		expl=gamm*yi;
		if (expl>50.0)
			expl=50.0;

		/* Density at altitude */
		densm_tmp = densm_tmp * (t1 / *tz) * exp(-expl);
	}

	if (alt>zn3[0]) {
		if (xm==0.0)
			return *tz;
		else
			return densm_tmp;
	}

	/* troposhere / stratosphere temperature */
	z = alt;
	mn = mn3;
	z1=zn3[0];
	z2=zn3[mn-1];
	t1=tn3[0];
	t2=tn3[mn-1];
	zg=zeta(z,z1);
	zgdif=zeta(z2,z1);

	/* set up spline nodes */
	for (k=0;k<mn;k++) {
		xs[k] = zeta(zn3[k],z1) / zgdif;
		ys[k] = 1.0 / tn3[k];
	}
	yd1=-tgn3[0] / (t1*t1) * zgdif;
	yd2=-tgn3[1] / (t2*t2) * zgdif * (pow(((re+z2)/(re+z1)),2.0));

	/* calculate spline coefficients */
	spline (xs, ys, mn, yd1, yd2, y2out);
	x = zg/zgdif;
	splint (xs, ys, y2out, mn, x, &y);

	/* temperature at altitude */
	*tz = 1.0 / y;
	if (xm!=0.0) {
		/* calaculate tropospheric / stratosphere density */
		glb = gsurf / (pow((1.0 + z1/re),2.0));
		gamm = xm * glb * zgdif / rgas;

		/* Integrate temperature profile */
		splini(xs, ys, y2out, mn, x, &yi);
		expl=gamm*yi;
		if (expl>50.0)
			expl=50.0;

		/* Density at altitude */
		densm_tmp = densm_tmp * (t1 / *tz) * exp(-expl);
	}
	if (xm==0.0)
		return *tz;
	else
		return densm_tmp;
}



/* ------------------------------------------------------------------- */
/* ------------------------------- DENSU ----------------------------- */
/* ------------------------------------------------------------------- */

double densu (double alt, double dlb, double tinf, double tlb, double xm, double alpha, double *tz, double zlb, double s2, int mn1, double *zn1, double *tn1, double *tgn1) {
/*      Calculate Temperature and Density Profiles for MSIS models
 *      New lower thermo polynomial
 */
	double yd2, yd1, x, y;
	double rgas=831.4;
	double densu_temp=1.0;
	double za, z, zg2, tt, ta;
	double dta, z1, z2, t1, t2, zg, zgdif;
	int mn;
	int k;
	double glb;
	double expl;
	double yi;
	double densa;
	double gamma, gamm;
	double xs[5], ys[5], y2out[5];
	/* joining altitudes of Bates and spline */
	za=zn1[0];
	if (alt>za)
		z=alt;
	else
		z=za;

	/* geopotential altitude difference from ZLB */
	zg2 = zeta(z, zlb);

	/* Bates temperature */
	tt = tinf - (tinf - tlb) * exp(-s2*zg2);
	ta = tt;
	*tz = tt;
	densu_temp = *tz;

	if (alt<za) {
		/* calculate temperature below ZA
		 * temperature gradient at ZA from Bates profile */
		dta = (tinf - ta) * s2 * pow(((re+zlb)/(re+za)),2.0);
		tgn1[0]=dta;
		tn1[0]=ta;
		if (alt>zn1[mn1-1])
			z=alt;
		else
			z=zn1[mn1-1];
		mn=mn1;
		z1=zn1[0];
		z2=zn1[mn-1];
		t1=tn1[0];
		t2=tn1[mn-1];
		/* geopotental difference from z1 */
		zg = zeta (z, z1);
		zgdif = zeta(z2, z1);
		/* set up spline nodes */
		for (k=0;k<mn;k++) {
			xs[k] = zeta(zn1[k], z1) / zgdif;
			ys[k] = 1.0 / tn1[k];
		}
		/* end node derivatives */
		yd1 = -tgn1[0] / (t1*t1) * zgdif;
		yd2 = -tgn1[1] / (t2*t2) * zgdif * pow(((re+z2)/(re+z1)),2.0);
		/* calculate spline coefficients */
		spline (xs, ys, mn, yd1, yd2, y2out);
		x = zg / zgdif;
		splint (xs, ys, y2out, mn, x, &y);
		/* temperature at altitude */
		*tz = 1.0 / y;
		densu_temp = *tz;
	}
	if (xm==0)
		return densu_temp;

	/* calculate density above za */
	glb = gsurf / pow((1.0 + zlb/re),2.0);
	gamma = xm * glb / (s2 * rgas * tinf);
	expl = exp(-s2 * gamma * zg2);
	if (expl>50.0)
  		expl=50.0;
	if (tt<=0)
		expl=50.0;

	/* density at altitude */
	densa = dlb * pow((tlb/tt),((1.0+alpha+gamma))) * expl;
	densu_temp=densa;
	if (alt>=za)
		return densu_temp;

	/* calculate density below za */
	glb = gsurf / pow((1.0 + z1/re),2.0);
	gamm = xm * glb * zgdif / rgas;

	/* integrate spline temperatures */
	splini (xs, ys, y2out, mn, x, &yi);
	expl = gamm * yi;
	if (expl>50.0)
		expl=50.0;
	if (*tz<=0)
		expl=50.0;

	/* density at altitude */
	densu_temp = densu_temp * pow ((t1 / *tz),(1.0 + alpha)) * exp(-expl);
	return densu_temp;
}



/* ------------------------------------------------------------------- */
/* ------------------------------- GLOBE7 ---------------------------- */
/* ------------------------------------------------------------------- */

/*    3hr Magnetic activity functions */
/*    Eq. A24d */
__inline_double g0(double a, double *p) {
	return (a - 4.0 + (p[25] - 1.0) * (a - 4.0 + (exp(-sqrt(p[24]*p[24]) * (a - 4.0)) - 1.0) / sqrt(p[24]*p[24])));
}

/*    Eq. A24c */
__inline_double sumex(double ex) {
	return (1.0 + (1.0 - pow(ex,19.0)) / (1.0 - ex) * pow(ex,0.5));
}

/*    Eq. A24a */
__inline_double sg0(double ex, double *p, double *ap) {
	return (g0(ap[1],p) + (g0(ap[2],p)*ex + g0(ap[3],p)*ex*ex + \
                g0(ap[4],p)*pow(ex,3.0)	+ (g0(ap[5],p)*pow(ex,4.0) + \
                g0(ap[6],p)*pow(ex,12.0))*(1.0-pow(ex,8.0))/(1.0-ex)))/sumex(ex);
}

double globe7(double *p, struct nrlmsise_input *input, struct nrlmsise_flags *flags) {
/*       CALCULATE G(L) FUNCTION 
 *       Upper Thermosphere Parameters */
	double t[15];
	int i,j;
	double apd;
	double tloc;
	double c, s, c2, c4, s2;
	double sr = 7.2722E-5;
	double dgtr = 1.74533E-2;
	double dr = 1.72142E-2;
	double hr = 0.2618;
	double cd32, cd18, cd14, cd39;
	double df;
	double f1, f2;
	double tinf;
	struct ap_array *ap;

	tloc=input->lst;
	for (j=0;j<14;j++)
		t[j]=0;

	/* calculate legendre polynomials */
	c = sin(input->g_lat * dgtr);
	s = cos(input->g_lat * dgtr);
	c2 = c*c;
	c4 = c2*c2;
	s2 = s*s;

	plg[0][1] = c;
	plg[0][2] = 0.5*(3.0*c2 -1.0);
	plg[0][3] = 0.5*(5.0*c*c2-3.0*c);
	plg[0][4] = (35.0*c4 - 30.0*c2 + 3.0)/8.0;
	plg[0][5] = (63.0*c2*c2*c - 70.0*c2*c + 15.0*c)/8.0;
	plg[0][6] = (11.0*c*plg[0][5] - 5.0*plg[0][4])/6.0;
/*      plg[0][7] = (13.0*c*plg[0][6] - 6.0*plg[0][5])/7.0; */
	plg[1][1] = s;
	plg[1][2] = 3.0*c*s;
	plg[1][3] = 1.5*(5.0*c2-1.0)*s;
	plg[1][4] = 2.5*(7.0*c2*c-3.0*c)*s;
	plg[1][5] = 1.875*(21.0*c4 - 14.0*c2 +1.0)*s;
	plg[1][6] = (11.0*c*plg[1][5]-6.0*plg[1][4])/5.0;
/*      plg[1][7] = (13.0*c*plg[1][6]-7.0*plg[1][5])/6.0; */
/*      plg[1][8] = (15.0*c*plg[1][7]-8.0*plg[1][6])/7.0; */
	plg[2][2] = 3.0*s2;
	plg[2][3] = 15.0*s2*c;
	plg[2][4] = 7.5*(7.0*c2 -1.0)*s2;
	plg[2][5] = 3.0*c*plg[2][4]-2.0*plg[2][3];
	plg[2][6] =(11.0*c*plg[2][5]-7.0*plg[2][4])/4.0;
	plg[2][7] =(13.0*c*plg[2][6]-8.0*plg[2][5])/5.0;
	plg[3][3] = 15.0*s2*s;
	plg[3][4] = 105.0*s2*s*c; 
	plg[3][5] =(9.0*c*plg[3][4]-7.*plg[3][3])/2.0;
	plg[3][6] =(11.0*c*plg[3][5]-8.*plg[3][4])/3.0;

	if (!(((flags->sw[7]==0)&&(flags->sw[8]==0))&&(flags->sw[14]==0))) {
		stloc = sin(hr*tloc);
		ctloc = cos(hr*tloc);
		s2tloc = sin(2.0*hr*tloc);
		c2tloc = cos(2.0*hr*tloc);
		s3tloc = sin(3.0*hr*tloc);
		c3tloc = cos(3.0*hr*tloc);
	}

	cd32 = cos(dr*(input->doy-p[31]));
	cd18 = cos(2.0*dr*(input->doy-p[17]));
	cd14 = cos(dr*(input->doy-p[13]));
	cd39 = cos(2.0*dr*(input->doy-p[38]));

	/* F10.7 EFFECT */
	df = input->f107 - input->f107A;
	dfa = input->f107A - 150.0;
	t[0] =  p[19]*df*(1.0+p[59]*dfa) + p[20]*df*df + p[21]*dfa + p[29]*pow(dfa,2.0);
	f1 = 1.0 + (p[47]*dfa +p[19]*df+p[20]*df*df)*flags->swc[1];
	f2 = 1.0 + (p[49]*dfa+p[19]*df+p[20]*df*df)*flags->swc[1];

	/*  TIME INDEPENDENT */
	t[1] = (p[1]*plg[0][2]+ p[2]*plg[0][4]+p[22]*plg[0][6]) + \
	      (p[14]*plg[0][2])*dfa*flags->swc[1] +p[26]*plg[0][1];

	/*  SYMMETRICAL ANNUAL */
	t[2] = p[18]*cd32;

	/*  SYMMETRICAL SEMIANNUAL */
	t[3] = (p[15]+p[16]*plg[0][2])*cd18;

	/*  ASYMMETRICAL ANNUAL */
	t[4] =  f1*(p[9]*plg[0][1]+p[10]*plg[0][3])*cd14;

	/*  ASYMMETRICAL SEMIANNUAL */
	t[5] =    p[37]*plg[0][1]*cd39;

        /* DIURNAL */
	if (flags->sw[7]) {
		double t71, t72;
		t71 = (p[11]*plg[1][2])*cd14*flags->swc[5];
		t72 = (p[12]*plg[1][2])*cd14*flags->swc[5];
		t[6] = f2*((p[3]*plg[1][1] + p[4]*plg[1][3] + p[27]*plg[1][5] + t71) * \
			   ctloc + (p[6]*plg[1][1] + p[7]*plg[1][3] + p[28]*plg[1][5] \
				    + t72)*stloc);
}

	/* SEMIDIURNAL */
	if (flags->sw[8]) {
		double t81, t82;
		t81 = (p[23]*plg[2][3]+p[35]*plg[2][5])*cd14*flags->swc[5];
		t82 = (p[33]*plg[2][3]+p[36]*plg[2][5])*cd14*flags->swc[5];
		t[7] = f2*((p[5]*plg[2][2]+ p[41]*plg[2][4] + t81)*c2tloc +(p[8]*plg[2][2] + p[42]*plg[2][4] + t82)*s2tloc);
	}

	/* TERDIURNAL */
	if (flags->sw[14]) {
		t[13] = f2 * ((p[39]*plg[3][3]+(p[93]*plg[3][4]+p[46]*plg[3][6])*cd14*flags->swc[5])* s3tloc +(p[40]*plg[3][3]+(p[94]*plg[3][4]+p[48]*plg[3][6])*cd14*flags->swc[5])* c3tloc);
}

	/* magnetic activity based on daily ap */
	if (flags->sw[9]==-1) {
		ap = input->ap_a;
		if (p[51]!=0) {
			double exp1;
			exp1 = exp(-10800.0*sqrt(p[51]*p[51])/(1.0+p[138]*(45.0-sqrt(input->g_lat*input->g_lat))));
			if (exp1>0.99999)
				exp1=0.99999;
			if (p[24]<1.0E-4)
				p[24]=1.0E-4;
			apt[0]=sg0(exp1,p,ap->a);
			/* apt[1]=sg2(exp1,p,ap->a);
			   apt[2]=sg0(exp2,p,ap->a);
			   apt[3]=sg2(exp2,p,ap->a);
			*/
			if (flags->sw[9]) {
				t[8] = apt[0]*(p[50]+p[96]*plg[0][2]+p[54]*plg[0][4]+ \
     (p[125]*plg[0][1]+p[126]*plg[0][3]+p[127]*plg[0][5])*cd14*flags->swc[5]+ \
     (p[128]*plg[1][1]+p[129]*plg[1][3]+p[130]*plg[1][5])*flags->swc[7]* \
					       cos(hr*(tloc-p[131])));
			}
		}
	} else {
		double p44, p45;
		apd=input->ap-4.0;
		p44=p[43];
		p45=p[44];
		if (p44<0)
			p44 = 1.0E-5;
		apdf = apd + (p45-1.0)*(apd + (exp(-p44 * apd) - 1.0)/p44);
		if (flags->sw[9]) {
			t[8]=apdf*(p[32]+p[45]*plg[0][2]+p[34]*plg[0][4]+ \
     (p[100]*plg[0][1]+p[101]*plg[0][3]+p[102]*plg[0][5])*cd14*flags->swc[5]+
     (p[121]*plg[1][1]+p[122]*plg[1][3]+p[123]*plg[1][5])*flags->swc[7]*
				    cos(hr*(tloc-p[124])));
		}
	}

	if ((flags->sw[10])&&(input->g_long>-1000.0)) {

		/* longitudinal */
		if (flags->sw[11]) {
			t[10] = (1.0 + p[80]*dfa*flags->swc[1])* \
     ((p[64]*plg[1][2]+p[65]*plg[1][4]+p[66]*plg[1][6]\
      +p[103]*plg[1][1]+p[104]*plg[1][3]+p[105]*plg[1][5]\
      +flags->swc[5]*(p[109]*plg[1][1]+p[110]*plg[1][3]+p[111]*plg[1][5])*cd14)* \
          cos(dgtr*input->g_long) \
      +(p[90]*plg[1][2]+p[91]*plg[1][4]+p[92]*plg[1][6]\
      +p[106]*plg[1][1]+p[107]*plg[1][3]+p[108]*plg[1][5]\
      +flags->swc[5]*(p[112]*plg[1][1]+p[113]*plg[1][3]+p[114]*plg[1][5])*cd14)* \
      sin(dgtr*input->g_long));
		}

		/* ut and mixed ut, longitude */
		if (flags->sw[12]){
			t[11]=(1.0+p[95]*plg[0][1])*(1.0+p[81]*dfa*flags->swc[1])*\
				(1.0+p[119]*plg[0][1]*flags->swc[5]*cd14)*\
				((p[68]*plg[0][1]+p[69]*plg[0][3]+p[70]*plg[0][5])*\
				cos(sr*(input->sec-p[71])));
			t[11]+=flags->swc[11]*\
				(p[76]*plg[2][3]+p[77]*plg[2][5]+p[78]*plg[2][7])*\
				cos(sr*(input->sec-p[79])+2.0*dgtr*input->g_long)*(1.0+p[137]*dfa*flags->swc[1]);
		}

		/* ut, longitude magnetic activity */
		if (flags->sw[13]) {
			if (flags->sw[9]==-1) {
				if (p[51]) {
					t[12]=apt[0]*flags->swc[11]*(1.+p[132]*plg[0][1])*\
						((p[52]*plg[1][2]+p[98]*plg[1][4]+p[67]*plg[1][6])*\
						 cos(dgtr*(input->g_long-p[97])))\
						+apt[0]*flags->swc[11]*flags->swc[5]*\
						(p[133]*plg[1][1]+p[134]*plg[1][3]+p[135]*plg[1][5])*\
						cd14*cos(dgtr*(input->g_long-p[136])) \
						+apt[0]*flags->swc[12]* \
						(p[55]*plg[0][1]+p[56]*plg[0][3]+p[57]*plg[0][5])*\
						cos(sr*(input->sec-p[58]));
				}
			} else {
				t[12] = apdf*flags->swc[11]*(1.0+p[120]*plg[0][1])*\
					((p[60]*plg[1][2]+p[61]*plg[1][4]+p[62]*plg[1][6])*\
					cos(dgtr*(input->g_long-p[63])))\
					+apdf*flags->swc[11]*flags->swc[5]* \
					(p[115]*plg[1][1]+p[116]*plg[1][3]+p[117]*plg[1][5])* \
					cd14*cos(dgtr*(input->g_long-p[118])) \
					+ apdf*flags->swc[12]* \
					(p[83]*plg[0][1]+p[84]*plg[0][3]+p[85]*plg[0][5])* \
					cos(sr*(input->sec-p[75]));
			}			
		}
	}

	/* parms not used: 82, 89, 99, 139-149 */
	tinf = p[30];
	for (i=0;i<14;i++)
		tinf = tinf + abs(flags->sw[i+1])*t[i];
	return tinf;
}



/* ------------------------------------------------------------------- */
/* ------------------------------- GLOB7S ---------------------------- */
/* ------------------------------------------------------------------- */

double glob7s(double *p, struct nrlmsise_input *input, struct nrlmsise_flags *flags) {
/*    VERSION OF GLOBE FOR LOWER ATMOSPHERE 10/26/99 
 */
	double pset=2.0;
	double t[14];
	double tt;
	double cd32, cd18, cd14, cd39;
	int i,j;
	double dr=1.72142E-2;
	double dgtr=1.74533E-2;
	/* confirm parameter set */
	if (p[99]==0)
		p[99]=pset;
	if (p[99]!=pset) {
		printf("Wrong parameter set for glob7s\n");
		return -1;
	}
	for (j=0;j<14;j++)
		t[j]=0.0;
	cd32 = cos(dr*(input->doy-p[31]));
	cd18 = cos(2.0*dr*(input->doy-p[17]));
	cd14 = cos(dr*(input->doy-p[13]));
	cd39 = cos(2.0*dr*(input->doy-p[38]));

	/* F10.7 */
	t[0] = p[21]*dfa;

	/* time independent */
	t[1]=p[1]*plg[0][2] + p[2]*plg[0][4] + p[22]*plg[0][6] + p[26]*plg[0][1] + p[14]*plg[0][3] + p[59]*plg[0][5];

        /* SYMMETRICAL ANNUAL */
	t[2]=(p[18]+p[47]*plg[0][2]+p[29]*plg[0][4])*cd32;

        /* SYMMETRICAL SEMIANNUAL */
	t[3]=(p[15]+p[16]*plg[0][2]+p[30]*plg[0][4])*cd18;

        /* ASYMMETRICAL ANNUAL */
	t[4]=(p[9]*plg[0][1]+p[10]*plg[0][3]+p[20]*plg[0][5])*cd14;

	/* ASYMMETRICAL SEMIANNUAL */
	t[5]=(p[37]*plg[0][1])*cd39;

        /* DIURNAL */
	if (flags->sw[7]) {
		double t71, t72;
		t71 = p[11]*plg[1][2]*cd14*flags->swc[5];
		t72 = p[12]*plg[1][2]*cd14*flags->swc[5];
		t[6] = ((p[3]*plg[1][1] + p[4]*plg[1][3] + t71) * ctloc + (p[6]*plg[1][1] + p[7]*plg[1][3] + t72) * stloc) ;
	}

	/* SEMIDIURNAL */
	if (flags->sw[8]) {
		double t81, t82;
		t81 = (p[23]*plg[2][3]+p[35]*plg[2][5])*cd14*flags->swc[5];
		t82 = (p[33]*plg[2][3]+p[36]*plg[2][5])*cd14*flags->swc[5];
		t[7] = ((p[5]*plg[2][2] + p[41]*plg[2][4] + t81) * c2tloc + (p[8]*plg[2][2] + p[42]*plg[2][4] + t82) * s2tloc);
	}

	/* TERDIURNAL */
	if (flags->sw[14]) {
		t[13] = p[39] * plg[3][3] * s3tloc + p[40] * plg[3][3] * c3tloc;
	}

	/* MAGNETIC ACTIVITY */
	if (flags->sw[9]) {
		if (flags->sw[9]==1)
			t[8] = apdf * (p[32] + p[45] * plg[0][2] * flags->swc[2]);
		if (flags->sw[9]==-1)	
			t[8]=(p[50]*apt[0] + p[96]*plg[0][2] * apt[0]*flags->swc[2]);
	}

	/* LONGITUDINAL */
	if (!((flags->sw[10]==0) || (flags->sw[11]==0) || (input->g_long<=-1000.0))) {
		t[10] = (1.0 + plg[0][1]*(p[80]*flags->swc[5]*cos(dr*(input->doy-p[81]))\
		        +p[85]*flags->swc[6]*cos(2.0*dr*(input->doy-p[86])))\
			+p[83]*flags->swc[3]*cos(dr*(input->doy-p[84]))\
			+p[87]*flags->swc[4]*cos(2.0*dr*(input->doy-p[88])))\
			*((p[64]*plg[1][2]+p[65]*plg[1][4]+p[66]*plg[1][6]\
			+p[74]*plg[1][1]+p[75]*plg[1][3]+p[76]*plg[1][5]\
			)*cos(dgtr*input->g_long)\
			+(p[90]*plg[1][2]+p[91]*plg[1][4]+p[92]*plg[1][6]\
			+p[77]*plg[1][1]+p[78]*plg[1][3]+p[79]*plg[1][5]\
			)*sin(dgtr*input->g_long));
	}
	tt=0;
	for (i=0;i<14;i++)
		tt+=abs(flags->sw[i+1])*t[i];
	return tt;
}



/* ------------------------------------------------------------------- */
/* ------------------------------- GTD7 ------------------------------ */
/* ------------------------------------------------------------------- */

void gtd7(struct nrlmsise_input *input, struct nrlmsise_flags *flags, struct nrlmsise_output *output) {
	double xlat;
	double xmm;
	int mn3 = 5;
	double zn3[5]={32.5,20.0,15.0,10.0,0.0};
	int mn2 = 4;
	double zn2[4]={72.5,55.0,45.0,32.5};
	double altt;
	double zmix=62.5;
	double tmp;
	double dm28m;
	double tz;
	double dmc;
	double dmr;
	double dz28;
	struct nrlmsise_output soutput;
	int i;

	tselec(flags);

	/* Latitude variation of gravity (none for sw[2]=0) */
	xlat=input->g_lat;
	if (flags->sw[2]==0)
		xlat=45.0;
	glatf(xlat, &gsurf, &re);

	xmm = pdm[2][4];

	/* THERMOSPHERE / MESOSPHERE (above zn2[0]) */
	if (input->alt>zn2[0])
		altt=input->alt;
	else
		altt=zn2[0];

	tmp=input->alt;
	input->alt=altt;
	gts7(input, flags, &soutput);
	altt=input->alt;
	input->alt=tmp;
	if (flags->sw[0])   /* metric adjustment */
		dm28m=dm28*1.0E6;
	else
		dm28m=dm28;
	output->t[0]=soutput.t[0];
	output->t[1]=soutput.t[1];
	if (input->alt>=zn2[0]) {
		for (i=0;i<9;i++)
			output->d[i]=soutput.d[i];
		return;
	}

/*       LOWER MESOSPHERE/UPPER STRATOSPHERE (between zn3[0] and zn2[0])
 *         Temperature at nodes and gradients at end nodes
 *         Inverse temperature a linear function of spherical harmonics
 */
	meso_tgn2[0]=meso_tgn1[1];
	meso_tn2[0]=meso_tn1[4];
        meso_tn2[1]=pma[0][0]*pavgm[0]/(1.0-flags->sw[20]*glob7s(pma[0], input, flags));
        meso_tn2[2]=pma[1][0]*pavgm[1]/(1.0-flags->sw[20]*glob7s(pma[1], input, flags));
        meso_tn2[3]=pma[2][0]*pavgm[2]/(1.0-flags->sw[20]*flags->sw[22]*glob7s(pma[2], input, flags));
	meso_tgn2[1]=pavgm[8]*pma[9][0]*(1.0+flags->sw[20]*flags->sw[22]*glob7s(pma[9], input, flags))*meso_tn2[3]*meso_tn2[3]/(pow((pma[2][0]*pavgm[2]),2.0));
	meso_tn3[0]=meso_tn2[3];

	if (input->alt<zn3[0]) {
/*       LOWER STRATOSPHERE AND TROPOSPHERE (below zn3[0])
 *         Temperature at nodes and gradients at end nodes
 *         Inverse temperature a linear function of spherical harmonics
 */
		meso_tgn3[0]=meso_tgn2[1];
		meso_tn3[1]=pma[3][0]*pavgm[3]/(1.0-flags->sw[22]*glob7s(pma[3], input, flags));
		meso_tn3[2]=pma[4][0]*pavgm[4]/(1.0-flags->sw[22]*glob7s(pma[4], input, flags));
		meso_tn3[3]=pma[5][0]*pavgm[5]/(1.0-flags->sw[22]*glob7s(pma[5], input, flags));
		meso_tn3[4]=pma[6][0]*pavgm[6]/(1.0-flags->sw[22]*glob7s(pma[6], input, flags));
		meso_tgn3[1]=pma[7][0]*pavgm[7]*(1.0+flags->sw[22]*glob7s(pma[7], input, flags)) *meso_tn3[4]*meso_tn3[4]/(pow((pma[6][0]*pavgm[6]),2.0));
	}

        /* LINEAR TRANSITION TO FULL MIXING BELOW zn2[0] */

	dmc=0;
	if (input->alt>zmix)
		dmc = 1.0 - (zn2[0]-input->alt)/(zn2[0] - zmix);
	dz28=soutput.d[2];
	
	/**** N2 density ****/
	dmr=soutput.d[2] / dm28m - 1.0;
	output->d[2]=densm(input->alt,dm28m,xmm, &tz, mn3, zn3, meso_tn3, meso_tgn3, mn2, zn2, meso_tn2, meso_tgn2);
	output->d[2]=output->d[2] * (1.0 + dmr*dmc);

	/**** HE density ****/
	dmr = soutput.d[0] / (dz28 * pdm[0][1]) - 1.0;
	output->d[0] = output->d[2] * pdm[0][1] * (1.0 + dmr*dmc);

	/**** O density ****/
	output->d[1] = 0;
	output->d[8] = 0;

	/**** O2 density ****/
	dmr = soutput.d[3] / (dz28 * pdm[3][1]) - 1.0;
	output->d[3] = output->d[2] * pdm[3][1] * (1.0 + dmr*dmc);

	/**** AR density ***/
	dmr = soutput.d[4] / (dz28 * pdm[4][1]) - 1.0;
	output->d[4] = output->d[2] * pdm[4][1] * (1.0 + dmr*dmc);

	/**** Hydrogen density ****/
	output->d[6] = 0;

	/**** Atomic nitrogen density ****/
	output->d[7] = 0;

	/**** Total mass density */
	output->d[5] = 1.66E-24 * (4.0 * output->d[0] + 16.0 * output->d[1] + 28.0 * output->d[2] + 32.0 * output->d[3] + 40.0 * output->d[4] + output->d[6] + 14.0 * output->d[7]);

	if (flags->sw[0])
		output->d[5]=output->d[5]/1000;

	/**** temperature at altitude ****/
	dd = densm(input->alt, 1.0, 0, &tz, mn3, zn3, meso_tn3, meso_tgn3, mn2, zn2, meso_tn2, meso_tgn2);
	output->t[1]=tz;

}



/* ------------------------------------------------------------------- */
/* ------------------------------- GTD7D ----------------------------- */
/* ------------------------------------------------------------------- */

void gtd7d(struct nrlmsise_input *input, struct nrlmsise_flags *flags, struct nrlmsise_output *output) {
	gtd7(input, flags, output);
	output->d[5] = 1.66E-24 * (4.0 * output->d[0] + 16.0 * output->d[1] + 28.0 * output->d[2] + 32.0 * output->d[3] + 40.0 * output->d[4] + output->d[6] + 14.0 * output->d[7] + 16.0 * output->d[8]);
	if (flags->sw[0])
		output->d[5]=output->d[5]/1000;
}
 


/* ------------------------------------------------------------------- */
/* -------------------------------- GHP7 ----------------------------- */
/* ------------------------------------------------------------------- */

void ghp7(struct nrlmsise_input *input, struct nrlmsise_flags *flags, struct nrlmsise_output *output, double press) {
	double bm = 1.3806E-19;
	double rgas = 831.4;
	double test = 0.00043;
	double ltest = 12;
	double pl, p;
	double zi;
	double z;
	double cl, cl2;
	double ca, cd;
	double xn, xm, diff;
	double g, sh;
	int l;
	pl = log10(press);
	if (pl >= -5.0) {
		if (pl>2.5)
			zi = 18.06 * (3.00 - pl);
		else if ((pl>0.075) && (pl<=2.5))
			zi = 14.98 * (3.08 - pl);
		else if ((pl>-1) && (pl<=0.075))
			zi = 17.80 * (2.72 - pl);
		else if ((pl>-2) && (pl<=-1))
			zi = 14.28 * (3.64 - pl);
		else if ((pl>-4) && (pl<=-2))
			zi = 12.72 * (4.32 -pl);
		else
			zi = 25.3 * (0.11 - pl);
		cl = input->g_lat/90.0;
		cl2 = cl*cl;
		if (input->doy<182)
			cd = (1.0 - (double) input->doy) / 91.25;
		else 
			cd = ((double) input->doy) / 91.25 - 3.0;
		ca = 0;
		if ((pl > -1.11) && (pl<=-0.23))
			ca = 1.0;
		if (pl > -0.23)
			ca = (2.79 - pl) / (2.79 + 0.23);
		if ((pl <= -1.11) && (pl>-3))
			ca = (-2.93 - pl)/(-2.93 + 1.11);
		z = zi - 4.87 * cl * cd * ca - 1.64 * cl2 * ca + 0.31 * ca * cl;
	} else
		z = 22.0 * pow((pl + 4.0),2.0) + 110.0;

	/* iteration  loop */
	l = 0;
	do {
		l++;
		input->alt = z;
		gtd7(input, flags, output);
		z = input->alt;
		xn = output->d[0] + output->d[1] + output->d[2] + output->d[3] + output->d[4] + output->d[6] + output->d[7];
		p = bm * xn * output->t[1];
		if (flags->sw[0])
			p = p*1.0E-6;
		diff = pl - log10(p);
		if (sqrt(diff*diff)<test)
			return;
		if (l==ltest) {
			printf("ERROR: ghp7 not converging for press %e, diff %e",press,diff);
			return;
		}
		xm = output->d[5] / xn / 1.66E-24;
		if (flags->sw[0])
			xm = xm * 1.0E3;
		g = gsurf / (pow((1.0 + z/re),2.0));
		sh = rgas * output->t[1] / (xm * g);

		/* new altitude estimate using scale height */
		if (l <  6)
			z = z - sh * diff * 2.302;
		else
			z = z - sh * diff;
	} while (1==1);
}



/* ------------------------------------------------------------------- */
/* ------------------------------- GTS7 ------------------------------ */
/* ------------------------------------------------------------------- */

void gts7(struct nrlmsise_input *input, struct nrlmsise_flags *flags, struct nrlmsise_output *output) {
/*     Thermospheric portion of NRLMSISE-00
 *     See GTD7 for more extensive comments
 *     alt > 72.5 km! 
 */
	double za;
	int i, j;
	double ddum, z;
	double zn1[5] = {120.0, 110.0, 100.0, 90.0, 72.5};
	double tinf;
	int mn1 = 5;
	double g0;
	double tlb;
	double s;
	double db01, db04, db14, db16, db28, db32, db40;
	double zh28, zh04, zh16, zh32, zh40, zh01, zh14;
	double zhm28, zhm04, zhm16, zhm32, zhm40, zhm01, zhm14;
	double xmd;
	double b28, b04, b16, b32, b40, b01, b14;
	double tz;
	double g28, g4, g16, g32, g40, g1, g14;
	double zhf, xmm;
	double zc04, zc16, zc32, zc40, zc01, zc14;
	double hc04, hc16, hc32, hc40, hc01, hc14;
	double hcc16, hcc32, hcc01, hcc14;
	double zcc16, zcc32, zcc01, zcc14;
	double rc16, rc32, rc01, rc14;
	double rl;
	double g16h, db16h, tho, zsht, zmho, zsho;
	double dgtr=1.74533E-2;
	double dr=1.72142E-2;
	double alpha[9]={-0.38, 0.0, 0.0, 0.0, 0.17, 0.0, -0.38, 0.0, 0.0};
	double altl[8]={200.0, 300.0, 160.0, 250.0, 240.0, 450.0, 320.0, 450.0};
	double dd;
	double hc216, hcc232;
	za = pdl[1][15];
	zn1[0] = za;
	for (j=0;j<9;j++) 
		output->d[j]=0;

	/* TINF VARIATIONS NOT IMPORTANT BELOW ZA OR ZN1(1) */
	if (input->alt>zn1[0])
		tinf = ptm[0]*pt[0] * \
			(1.0+flags->sw[16]*globe7(pt,input,flags));
	else
		tinf = ptm[0]*pt[0];
	output->t[0]=tinf;

	/*  GRADIENT VARIATIONS NOT IMPORTANT BELOW ZN1(5) */
	if (input->alt>zn1[4])
		g0 = ptm[3]*ps[0] * \
			(1.0+flags->sw[19]*globe7(ps,input,flags));
	else
		g0 = ptm[3]*ps[0];
	tlb = ptm[1] * (1.0 + flags->sw[17]*globe7(pd[3],input,flags))*pd[3][0];
	s = g0 / (tinf - tlb);

/*      Lower thermosphere temp variations not significant for
 *       density above 300 km */
	if (input->alt<300.0) {
		meso_tn1[1]=ptm[6]*ptl[0][0]/(1.0-flags->sw[18]*glob7s(ptl[0], input, flags));
		meso_tn1[2]=ptm[2]*ptl[1][0]/(1.0-flags->sw[18]*glob7s(ptl[1], input, flags));
		meso_tn1[3]=ptm[7]*ptl[2][0]/(1.0-flags->sw[18]*glob7s(ptl[2], input, flags));
		meso_tn1[4]=ptm[4]*ptl[3][0]/(1.0-flags->sw[18]*flags->sw[20]*glob7s(ptl[3], input, flags));
		meso_tgn1[1]=ptm[8]*pma[8][0]*(1.0+flags->sw[18]*flags->sw[20]*glob7s(pma[8], input, flags))*meso_tn1[4]*meso_tn1[4]/(pow((ptm[4]*ptl[3][0]),2.0));
	} else {
		meso_tn1[1]=ptm[6]*ptl[0][0];
		meso_tn1[2]=ptm[2]*ptl[1][0];
		meso_tn1[3]=ptm[7]*ptl[2][0];
		meso_tn1[4]=ptm[4]*ptl[3][0];
		meso_tgn1[1]=ptm[8]*pma[8][0]*meso_tn1[4]*meso_tn1[4]/(pow((ptm[4]*ptl[3][0]),2.0));
	}

	/* N2 variation factor at Zlb */
	g28=flags->sw[21]*globe7(pd[2], input, flags);

	/* VARIATION OF TURBOPAUSE HEIGHT */
	zhf=pdl[1][24]*(1.0+flags->sw[5]*pdl[0][24]*sin(dgtr*input->g_lat)*cos(dr*(input->doy-pt[13])));
	output->t[0]=tinf;
	xmm = pdm[2][4];
	z = input->alt;


        /**** N2 DENSITY ****/

	/* Diffusive density at Zlb */
	db28 = pdm[2][0]*exp(g28)*pd[2][0];
	/* Diffusive density at Alt */
	output->d[2]=densu(z,db28,tinf,tlb,28.0,alpha[2],&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
	dd=output->d[2];
	/* Turbopause */
	zh28=pdm[2][2]*zhf;
	zhm28=pdm[2][3]*pdl[1][5]; 
	xmd=28.0-xmm;
	/* Mixed density at Zlb */
	b28=densu(zh28,db28,tinf,tlb,xmd,(alpha[2]-1.0),&tz,ptm[5],s,mn1, zn1,meso_tn1,meso_tgn1);
	if ((flags->sw[15])&&(z<=altl[2])) {
		/*  Mixed density at Alt */
		dm28=densu(z,b28,tinf,tlb,xmm,alpha[2],&tz,ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
		/*  Net density at Alt */
		output->d[2]=dnet(output->d[2],dm28,zhm28,xmm,28.0);
	}


        /**** HE DENSITY ****/

	/*   Density variation factor at Zlb */
	g4 = flags->sw[21]*globe7(pd[0], input, flags);
	/*  Diffusive density at Zlb */
	db04 = pdm[0][0]*exp(g4)*pd[0][0];
        /*  Diffusive density at Alt */
	output->d[0]=densu(z,db04,tinf,tlb, 4.,alpha[0],&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
	dd=output->d[0];
	if ((flags->sw[15]) && (z<altl[0])) {
		/*  Turbopause */
		zh04=pdm[0][2];
		/*  Mixed density at Zlb */
		b04=densu(zh04,db04,tinf,tlb,4.-xmm,alpha[0]-1.,&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
		/*  Mixed density at Alt */
		dm04=densu(z,b04,tinf,tlb,xmm,0.,&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
		zhm04=zhm28;
		/*  Net density at Alt */
		output->d[0]=dnet(output->d[0],dm04,zhm04,xmm,4.);
		/*  Correction to specified mixing ratio at ground */
		rl=log(b28*pdm[0][1]/b04);
		zc04=pdm[0][4]*pdl[1][0];
		hc04=pdm[0][5]*pdl[1][1];
		/*  Net density corrected at Alt */
		output->d[0]=output->d[0]*ccor(z,rl,hc04,zc04);
	}


        /**** O DENSITY ****/

	/*  Density variation factor at Zlb */
	g16= flags->sw[21]*globe7(pd[1],input,flags);
	/*  Diffusive density at Zlb */
	db16 =  pdm[1][0]*exp(g16)*pd[1][0];
        /*   Diffusive density at Alt */
	output->d[1]=densu(z,db16,tinf,tlb, 16.,alpha[1],&output->t[1],ptm[5],s,mn1, zn1,meso_tn1,meso_tgn1);
	dd=output->d[1];
	if ((flags->sw[15]) && (z<=altl[1])) {
		/*   Turbopause */
		zh16=pdm[1][2];
		/*  Mixed density at Zlb */
		b16=densu(zh16,db16,tinf,tlb,16.0-xmm,(alpha[1]-1.0), &output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
		/*  Mixed density at Alt */
		dm16=densu(z,b16,tinf,tlb,xmm,0.,&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
		zhm16=zhm28;
		/*  Net density at Alt */
		output->d[1]=dnet(output->d[1],dm16,zhm16,xmm,16.);
		rl=pdm[1][1]*pdl[1][16]*(1.0+flags->sw[1]*pdl[0][23]*(input->f107A-150.0));
		hc16=pdm[1][5]*pdl[1][3];
		zc16=pdm[1][4]*pdl[1][2];
		hc216=pdm[1][5]*pdl[1][4];
		output->d[1]=output->d[1]*ccor2(z,rl,hc16,zc16,hc216);
		/*   Chemistry correction */
		hcc16=pdm[1][7]*pdl[1][13];
		zcc16=pdm[1][6]*pdl[1][12];
		rc16=pdm[1][3]*pdl[1][14];
		/*  Net density corrected at Alt */
		output->d[1]=output->d[1]*ccor(z,rc16,hcc16,zcc16);
	}


        /**** O2 DENSITY ****/

        /*   Density variation factor at Zlb */
	g32= flags->sw[21]*globe7(pd[4], input, flags);
        /*  Diffusive density at Zlb */
	db32 = pdm[3][0]*exp(g32)*pd[4][0];
        /*   Diffusive density at Alt */
	output->d[3]=densu(z,db32,tinf,tlb, 32.,alpha[3],&output->t[1],ptm[5],s,mn1, zn1,meso_tn1,meso_tgn1);
	dd=output->d[3];
	if (flags->sw[15]) {
		if (z<=altl[3]) {
			/*   Turbopause */
			zh32=pdm[3][2];
			/*  Mixed density at Zlb */
			b32=densu(zh32,db32,tinf,tlb,32.-xmm,alpha[3]-1., &output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
			/*  Mixed density at Alt */
			dm32=densu(z,b32,tinf,tlb,xmm,0.,&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
			zhm32=zhm28;
			/*  Net density at Alt */
			output->d[3]=dnet(output->d[3],dm32,zhm32,xmm,32.);
			/*   Correction to specified mixing ratio at ground */
			rl=log(b28*pdm[3][1]/b32);
			hc32=pdm[3][5]*pdl[1][7];
			zc32=pdm[3][4]*pdl[1][6];
			output->d[3]=output->d[3]*ccor(z,rl,hc32,zc32);
		}
		/*  Correction for general departure from diffusive equilibrium above Zlb */
		hcc32=pdm[3][7]*pdl[1][22];
		hcc232=pdm[3][7]*pdl[0][22];
		zcc32=pdm[3][6]*pdl[1][21];
		rc32=pdm[3][3]*pdl[1][23]*(1.+flags->sw[1]*pdl[0][23]*(input->f107A-150.));
		/*  Net density corrected at Alt */
		output->d[3]=output->d[3]*ccor2(z,rc32,hcc32,zcc32,hcc232);
	}


        /**** AR DENSITY ****/

        /*   Density variation factor at Zlb */
	g40= flags->sw[21]*globe7(pd[5],input,flags);
        /*  Diffusive density at Zlb */
	db40 = pdm[4][0]*exp(g40)*pd[5][0];
	/*   Diffusive density at Alt */
	output->d[4]=densu(z,db40,tinf,tlb, 40.,alpha[4],&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
	dd=output->d[4];
	if ((flags->sw[15]) && (z<=altl[4])) {
		/*   Turbopause */
		zh40=pdm[4][2];
		/*  Mixed density at Zlb */
		b40=densu(zh40,db40,tinf,tlb,40.-xmm,alpha[4]-1.,&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
		/*  Mixed density at Alt */
		dm40=densu(z,b40,tinf,tlb,xmm,0.,&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
		zhm40=zhm28;
		/*  Net density at Alt */
		output->d[4]=dnet(output->d[4],dm40,zhm40,xmm,40.);
		/*   Correction to specified mixing ratio at ground */
		rl=log(b28*pdm[4][1]/b40);
		hc40=pdm[4][5]*pdl[1][9];
		zc40=pdm[4][4]*pdl[1][8];
		/*  Net density corrected at Alt */
		output->d[4]=output->d[4]*ccor(z,rl,hc40,zc40);
	  }


        /**** HYDROGEN DENSITY ****/

        /*   Density variation factor at Zlb */
	g1 = flags->sw[21]*globe7(pd[6], input, flags);
        /*  Diffusive density at Zlb */
	db01 = pdm[5][0]*exp(g1)*pd[6][0];
        /*   Diffusive density at Alt */
	output->d[6]=densu(z,db01,tinf,tlb,1.,alpha[6],&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
	dd=output->d[6];
	if ((flags->sw[15]) && (z<=altl[6])) {
		/*   Turbopause */
		zh01=pdm[5][2];
		/*  Mixed density at Zlb */
		b01=densu(zh01,db01,tinf,tlb,1.-xmm,alpha[6]-1., &output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
		/*  Mixed density at Alt */
		dm01=densu(z,b01,tinf,tlb,xmm,0.,&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
		zhm01=zhm28;
		/*  Net density at Alt */
		output->d[6]=dnet(output->d[6],dm01,zhm01,xmm,1.);
		/*   Correction to specified mixing ratio at ground */
		rl=log(b28*pdm[5][1]*sqrt(pdl[1][17]*pdl[1][17])/b01);
		hc01=pdm[5][5]*pdl[1][11];
		zc01=pdm[5][4]*pdl[1][10];
		output->d[6]=output->d[6]*ccor(z,rl,hc01,zc01);
		/*   Chemistry correction */
		hcc01=pdm[5][7]*pdl[1][19];
		zcc01=pdm[5][6]*pdl[1][18];
		rc01=pdm[5][3]*pdl[1][20];
		/*  Net density corrected at Alt */
		output->d[6]=output->d[6]*ccor(z,rc01,hcc01,zcc01);
}


        /**** ATOMIC NITROGEN DENSITY ****/

	/*   Density variation factor at Zlb */
	g14 = flags->sw[21]*globe7(pd[7],input,flags);
        /*  Diffusive density at Zlb */
	db14 = pdm[6][0]*exp(g14)*pd[7][0];
        /*   Diffusive density at Alt */
	output->d[7]=densu(z,db14,tinf,tlb,14.,alpha[7],&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
	dd=output->d[7];
	if ((flags->sw[15]) && (z<=altl[7])) {
		/*   Turbopause */
		zh14=pdm[6][2];
		/*  Mixed density at Zlb */
		b14=densu(zh14,db14,tinf,tlb,14.-xmm,alpha[7]-1., &output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
		/*  Mixed density at Alt */
		dm14=densu(z,b14,tinf,tlb,xmm,0.,&output->t[1],ptm[5],s,mn1,zn1,meso_tn1,meso_tgn1);
		zhm14=zhm28;
		/*  Net density at Alt */
		output->d[7]=dnet(output->d[7],dm14,zhm14,xmm,14.);
		/*   Correction to specified mixing ratio at ground */
		rl=log(b28*pdm[6][1]*sqrt(pdl[0][2]*pdl[0][2])/b14);
		hc14=pdm[6][5]*pdl[0][1];
		zc14=pdm[6][4]*pdl[0][0];
		output->d[7]=output->d[7]*ccor(z,rl,hc14,zc14);
		/*   Chemistry correction */
		hcc14=pdm[6][7]*pdl[0][4];
		zcc14=pdm[6][6]*pdl[0][3];
		rc14=pdm[6][3]*pdl[0][5];
		/*  Net density corrected at Alt */
		output->d[7]=output->d[7]*ccor(z,rc14,hcc14,zcc14);
	}


        /**** Anomalous OXYGEN DENSITY ****/

	g16h = flags->sw[21]*globe7(pd[8],input,flags);
	db16h = pdm[7][0]*exp(g16h)*pd[8][0];
	tho = pdm[7][9]*pdl[0][6];
	dd=densu(z,db16h,tho,tho,16.,alpha[8],&output->t[1],ptm[5],s,mn1, zn1,meso_tn1,meso_tgn1);
	zsht=pdm[7][5];
	zmho=pdm[7][4];
	zsho=scalh(zmho,16.0,tho);
	output->d[8]=dd*exp(-zsht/zsho*(exp(-(z-zmho)/zsht)-1.));


	/* total mass density */
	output->d[5] = 1.66E-24*(4.0*output->d[0]+16.0*output->d[1]+28.0*output->d[2]+32.0*output->d[3]+40.0*output->d[4]+ output->d[6]+14.0*output->d[7]);


	/* temperature */
	z = sqrt(input->alt*input->alt);
	ddum = densu(z,1.0, tinf, tlb, 0.0, 0.0, &output->t[1], ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1);
	(void) ddum; /* silence gcc */
	if (flags->sw[0]) {
		for(i=0;i<9;i++)
			output->d[i]=output->d[i]*1.0E6;
		output->d[5]=output->d[5]/1000;
	}
}





//
// alt [m]
// lambda [um]
//
// computes N = (n-1)
float AtmosphericTurbulence_stdAtmModel_N(float alt, float lambdaum)
{
	float dens;
	float val;
	double n;
 	struct nrlmsise_output output; 
	struct nrlmsise_input input;
  	struct nrlmsise_flags flags;
	long i;
	float ifrac;
	double LLN2, LLO2, LLCO2, LLHe, LLAr, LLH, LLO, LLNe, LLH2O;
	double LoschmidtConstant =  2.6867805e25; // for  1 atm (= 101.325 kPa) and 0 °C (= 273.15 K)
	double LL;
	double denstot;


	i = (long) (alt/100.0);
	if(i>998)
		i = 999;
	ifrac = 1.0*alt/100.0 - i;
	
	if(ifrac<0)
		ifrac = 0.0;
	
	if(ifrac>1.0)
		ifrac = 1.0;


	denstot = 0.0;
	// N2
	n = OPTICSMATERIALS_n(5, (double) (lambdaum*1e-6));
	LLN2 = (n*n-1)/(n*n+2);
	LLN2 *= ((1.0-ifrac)*densN2[i]+ifrac*densN2[i+1])/(LoschmidtConstant/1e6);
	denstot += ((1.0-ifrac)*densN2[i]+ifrac*densN2[i+1]);
	
	// O2
	n = OPTICSMATERIALS_n(6, (double) (lambdaum*1e-6));
	LLO2 = (n*n-1)/(n*n+2);
	LLO2 *= ((1.0-ifrac)*densO2[i]+ifrac*densO2[i+1])/(LoschmidtConstant/1e6);
	denstot += ((1.0-ifrac)*densO2[i]+ifrac*densO2[i+1]);
	
	// Ar
	n = OPTICSMATERIALS_n(7, (double) (lambdaum*1e-6));
	LLAr = (n*n-1)/(n*n+2);
	LLAr *= ((1.0-ifrac)*densAr[i]+ifrac*densAr[i+1])/(LoschmidtConstant/1e6);
	denstot += ((1.0-ifrac)*densAr[i]+ifrac*densAr[i+1]);
	
	// He
	n = OPTICSMATERIALS_n(8, (double) (lambdaum*1e-6));
	LLHe = (n*n-1)/(n*n+2);
	LLHe *= ((1.0-ifrac)*densHe[i]+ifrac*densHe[i+1])/(LoschmidtConstant/1e6);
	denstot += ((1.0-ifrac)*densHe[i]+ifrac*densHe[i+1]);
	
	// CO2
	n = OPTICSMATERIALS_n(11, (double) (lambdaum*1e-6));
	LLCO2 = (n*n-1)/(n*n+2);
	LLCO2 *= ((1.0-ifrac)*densCO2[i]+ifrac*densCO2[i+1])/(LoschmidtConstant/1e6);
	denstot += ((1.0-ifrac)*densCO2[i]+ifrac*densCO2[i+1]);

	// O
	n = OPTICSMATERIALS_n(13, (double) (lambdaum*1e-6));
	LLO = (n*n-1)/(n*n+2);
	LLO *= ((1.0-ifrac)*densO[i]+ifrac*densO[i+1])/(LoschmidtConstant/1e6);
	denstot += ((1.0-ifrac)*densO[i]+ifrac*densO[i+1]);

	// Ne
	n = OPTICSMATERIALS_n(12, (double) (lambdaum*1e-6));
	LLNe = (n*n-1)/(n*n+2);
	LLNe *= ((1.0-ifrac)*densNe[i]+ifrac*densNe[i+1])/(LoschmidtConstant/1e6);
	denstot += ((1.0-ifrac)*densNe[i]+ifrac*densNe[i+1]);
	
	// H2O
	n = OPTICSMATERIALS_n(10, (double) (lambdaum*1e-6));
	LLH2O = (n*n-1)/(n*n+2);
	LLH2O *= ((1.0-ifrac)*densH2O[i]+ifrac*densH2O[i+1])/(LoschmidtConstant/1e6);
	denstot += ((1.0-ifrac)*densH2O[i]+ifrac*densH2O[i+1]);
	
	LL = LLN2 + LLO2 + LLAr + LLHe + LLCO2 + LLO + LLNe + LLH2O;
	
	n = sqrt((2.0*LL+1.0)/(1.0-LL));
	

	// simple model: use overall density 
//	val = 0.0000834213+0.0240603/(130.0-1.0/pow(lambdaum,2.0))+0.00015997/(38.9-1.0/pow(lambdaum,2.0));
//	val *= (dens/0.001178);

	val = n-1.0;
	
	
		
//	printf("===== %5ld  %10g   %10g  %10g     %10g\n ", i, (double) alt, ifrac, val, LL);
	
	
	//,  1.0+(0.0000834213+0.0240603/(130.0-1.0/pow(lambdaum,2.0))+0.00015997/(38.9-1.0/pow(lambdaum,2.0)))*(dens/0.001178));
	//(double) densH2O[i], (double) dens0,  densH2O[i]/dens0, val, OPTICSMATERIALS_n(10, lambdaum/1000000.0));
	
	//dens = (1.0-ifrac)*densH2O[i] + ifrac*densH2O[i];
	//val = (1.0-dens/dens0)*val + dens/dens0*(OPTICSMATERIALS_n(10, lambdaum/1000000.0)-1.0);
	
	//printf("-> %g  %g [%g %f]\n", val, n-1.0, denstot/(LoschmidtConstant/1e6), output.t[1]);
	
//	printf(" [%g %g -> %g %g] ", alt, lambdaum, val, dens/0.001178);

	return(val);
}








int AtmosphericTurbulence_build_stdAtmModel(char *fname)
{
	FILE *fp;
  	struct nrlmsise_output output[1000]; // 100m steps from h=0 to h=100km
	struct nrlmsise_input input[1000];
  	struct nrlmsise_flags flags;
//	struct ap_array aph; // magnetic values
	int i;
	int j;
	double TotPart; // total number of particules per cm2
	double TotPart0;
	double TotPart1, TotPart2; // for H2O
	double h; // elevation
	double X;
	double coeff;
	
	double LLN2, LLO2, LLCO2, LLHe, LLAr, LLH;
		
			
	/* input values */
//  	for (i=0;i<7;i++)
//		aph.a[i]=100;
	flags.switches[0]=0;
  	for (i=1;i<24;i++)
  		flags.switches[i]=1;

	for (i=0;i<1000;i++) {
		input[i].doy=172;
		input[i].year=0; /* without effect */
  		input[i].sec=29000;
		input[i].alt=0.1*i;
		input[i].g_lat=20;
		input[i].g_long=-70;
		input[i].lst=16;
		input[i].f107A=150;
		input[i].f107=150;
		input[i].ap=4;
	}

	fp = fopen(fname, "w");
	/* evaluate 0 to 1000 */
  	fprintf(fp, "#  alt[m]  N2  O2  Ar  H  He  O   N  density\n");
	TotPart = 0.0;
	TotPart1 = 0.0;
	TotPart2 = 0.0;
	dens0 = 1;

  	densN2 = (float*) malloc(sizeof(float)*1000);
  	densO2 = (float*) malloc(sizeof(float)*1000);
  	densAr = (float*) malloc(sizeof(float)*1000);
  	densHe = (float*) malloc(sizeof(float)*1000);
  	densO = (float*) malloc(sizeof(float)*1000);
  	densN = (float*) malloc(sizeof(float)*1000);
	densH = (float*) malloc(sizeof(float)*1000);
	
  	densH2O = (float*) malloc(sizeof(float)*1000);
  	densCO2 = (float*) malloc(sizeof(float)*1000);
  	densNe = (float*) malloc(sizeof(float)*1000);

  	for (i=0;i<1000;i++)
  		{
			h = 100.0*i;
			gtd7(&input[i], &flags, &output[i]);
			fprintf(fp, "%6.0f %12f %12f %12f %12f %12f %12f %12f %.8g\n", input[i].alt*1000.0, output[i].d[2], output[i].d[3], output[i].d[4], output[i].d[6], output[i].d[0], output[i].d[1]+output[i].d[8], output[i].d[7], output[i].d[5]);
			TotPart0 = 0.0;
			TotPart0 += output[i].d[0];
			TotPart0 += output[i].d[1];
			TotPart0 += output[i].d[2];
			TotPart0 += output[i].d[3];
			TotPart0 += output[i].d[4];
			TotPart0 += output[i].d[6];
			TotPart0 += output[i].d[7];
			TotPart0 += output[i].d[8];
		
			densNe[i] = output[i].d[2] * 2.328e-5;
			TotPart0 += densNe[i];
			
			if(h<70000)
				densCO2[i] = 400.0e-6*TotPart0;
			else
				densCO2[i] = (400.0-0.007*(h-70000))*1e-6*TotPart0;
			TotPart0 += densCO2[i];
			
			if(i==0)
				dens0 = TotPart0;
			TotPart0 *= 100000.0; // 100m = 10000cm
			// TotPart0 is the number of particles per cm2 for the altitude bin
			
			if(h>SiteAlt)
			{
				TotPart += TotPart0; // cumulative			
				TotPart1 += 2.5e-6*TotPart0*exp(-3.0*pow(h/100000.0,4.0));
				TotPart2 += (exp(-h/SitePWSH))*TotPart0*exp(-3.0*pow(h/100000.0,4.0));
	//			printf("===== %f %f %f\n", TotPart, TotPart0, TotPart1);
			}
			
			densH2O[i] = 2.5e-6*TotPart0;
		}
	fclose(fp);
	
	printf("TOTAL particles : %g part.cm^-2\n", TotPart);
	printf("TOTAL particles H2O fixed mixing ratio : %g part.cm^-2    ( SitePWSH = %f, SiteAlt = %f m)\n", TotPart1, SitePWSH, SiteAlt);
	X = SiteTPW*0.1*6.022e23/18.0; // total particules of H2O per cm2
	printf("TOTAL H2O particles: %g part.cm^-2\n", X);


	alpha1H2O = (X-TotPart1)/TotPart2;
	if(alpha1H2O<0.0)
		{
			printf("ERROR: total precititable water value is too low, and not consistent with atmospheric model\n");
			exit(0);
		}
	printf("alpha1H2O = %g\n", alpha1H2O);
	
	fp = fopen(fname, "w");
	/* evaluate 0 to 1000 */
  	fprintf(fp, "#  alt[m]  N2  O2  Ar  H  He  O   N  H2O   CO2  Ne  density\n");
	TotPart = 0.0;
	TotPart1 = 0.0;
	TotPart2 = 0.0;
  	for (i=0;i<1000;i++)
  		{
			h = 100.0*i;
		//	gtd7(&input[i], &flags, &output[i]);

			densH2O[i] += alpha1H2O*(exp(-h/SitePWSH))*(densH2O[i]/2.5e-6)*exp(-3.0*pow(h/100000.0,4.0));
			densH2O[i] /= 10000.0;
			if(h>SiteAlt)
				TotPart1 += densH2O[i]*10000.0;

			coeff = (output[i].d[0]+output[i].d[1]+output[i].d[2]+output[i].d[3]+output[i].d[4]+output[i].d[6]+output[i].d[7]+output[i].d[8]+densCO2[i]+densNe[i]+densH2O[i])/(output[i].d[0]+output[i].d[1]+output[i].d[2]+output[i].d[3]+output[i].d[4]+output[i].d[6]+output[i].d[7]+output[i].d[8]+densCO2[i]+densNe[i]);
			
			//printf("%10f  H2O coeff = %f\n", h, coeff);
			
			output[i].d[0] /= coeff;  	// He
			densHe[i] = output[i].d[0];
			
			output[i].d[1] /= coeff;	// O
			densO[i] = output[i].d[1];
			
			output[i].d[2] /= coeff;	// N2
			densN2[i] = output[i].d[2];
			
			output[i].d[3] /= coeff;	// O2
			densO2[i] = output[i].d[3];
			
			output[i].d[4] /= coeff;	// Ar
			densAr[i] = output[i].d[4];

			output[i].d[6] /= coeff;	// H
			densH[i] = output[i].d[6];

			output[i].d[7] /= coeff;	// N
			densN[i] = output[i].d[7];

			output[i].d[8] /= coeff;	// anomalous O
			densO[i] += output[i].d[8];

			densH2O[i] /= coeff;
			
			densCO2[i] /= coeff;
			
			densNe[i] /= coeff;
			
			
			fprintf(fp, "%6.0f %12f %12f %12f %12f %12f %12f %12f %12f %12f %12f %.8g\n", input[i].alt*1000.0, densN2[i], densO2[i], densAr[i], densH[i], densHe[i], densO[i], densN[i], densH2O[i], densCO2[i], densNe[i], output[i].d[5]);
		}
	fclose(fp);
	printf("TOTAL = %g\n", TotPart1);
	
	
	
	
	return(0);
}
















int AtmosphericTurbulence_change_configuration_file(char *fname)
{
  sprintf(CONFFILE, "%s", fname);
  
  return(0);
}



//
// innerscale and outerscale in pixel 
//
int make_master_turbulence_screen(char *ID_name1, char *ID_name2, long size, float outerscale, float innerscale)
{
  long ID,ii,jj;
  float value,C1,C2;
  long cnt;
  long Dlim = 3;
  long IDv;

  int OUTERSCALE_MODE = 1; // 1 if outer scale
  double OUTERscale_f0;
  double INNERscale_f0;
  double dx, dy, r;
  double rlim = 0.0;
  int RLIMMODE = 0;
  double iscoeff;
  
/*  IDv = variable_ID("OUTERSCALE");
  if(IDv!=-1)
    {
      outerscale = data.variable[IDv].value.f;
      printf("Outer scale = %f pix\n", outerscale);
    }
 */
 
  IDv = variable_ID("RLIM");
  if(IDv!=-1)
    {
      RLIMMODE = 1;
      rlim = data.variable[IDv].value.f;
      printf("R limit = %f pix\n",rlim);
    }

  OUTERscale_f0 = 1.0*size/outerscale; // [1/pix] in F plane
  INNERscale_f0 = 1.0*size/innerscale; 

  make_rnd("tmppha",size,size,"");
  arith_image_cstmult("tmppha",2.0*PI,"tmppha1");
  delete_image_ID("tmppha");
  //  make_dist("tmpd",size,size,size/2,size/2);
  ID = create_2Dimage_ID("tmpd",size,size);
  for(ii=0;ii<size;ii++)
    for(jj=0;jj<size;jj++)
      {
	dx = 1.0*ii-size/2;
	dy = 1.0*jj-size/2;

	if(RLIMMODE==1)
	  {
	    r = sqrt(dx*dx + dy*dy);
	    if(r<rlim)
	      data.image[ID].array.F[jj*size+ii] = 0.0;
	    else
	      data.image[ID].array.F[jj*size+ii] = sqrt(dx*dx + dy*dy + OUTERscale_f0*OUTERscale_f0);
	  }
	else
	  data.image[ID].array.F[jj*size+ii] = sqrt(dx*dx + dy*dy + OUTERscale_f0*OUTERscale_f0);
      }
  //  data.image[ID].array.F[size/2*size+size/2+10] = 1.0;

  // period [pix] = size/sqrt(dx*dx+dy*dy)
  // f [1/pix] = sqrt(dx*dx+dy*dy)/size
  // f [1/pix] * size = sqrt(dx*dx+dy*dy)

  make_rnd("tmpg",size,size,"-gauss");
  ID = image_ID("tmpg");
  for(ii=0;ii<size;ii++)
    for(jj=0;jj<size;jj++)
	{
		dx = 1.0*ii-size/2;
		dy = 1.0*jj-size/2;
		iscoeff = exp(-(dx*dx+dy*dy)/INNERscale_f0/INNERscale_f0);
		data.image[ID].array.F[jj*size+ii] *= iscoeff;
	}
  
  arith_image_cstpow("tmpd", 11.0/6.0, "tmpd1");
  delete_image_ID("tmpd");
  arith_image_div("tmpg", "tmpd1", "tmpamp");
  delete_image_ID("tmpg");
  delete_image_ID("tmpd1");
  arith_set_pixel("tmpamp", 0.0, size/2, size/2);
  mk_complex_from_amph("tmpamp", "tmppha1", "tmpc");
  delete_image_ID("tmpamp");
  delete_image_ID("tmppha1");
  permut("tmpc");
  do2dfft("tmpc","tmpcf");
  delete_image_ID("tmpc");
  mk_reim_from_complex("tmpcf", "tmpo1", "tmpo2");
  delete_image_ID("tmpcf");

  /* compute the scaling factor in the power law of the structure function */
  fft_structure_function("tmpo1", "strf");
  ID = image_ID("strf");
  value = 0.0;
  cnt = 0;
  for(ii = 1;ii<Dlim;ii++)
    for(jj = 1;jj<Dlim;jj++)
      {
	value += log10(data.image[ID].array.F[jj*size+ii])-5.0/3.0*log10(sqrt(ii*ii+jj*jj)); 
	cnt++;
      }
  // save_fl_fits("strf","!strf.fits");
  delete_image_ID("strf");
  C1 = pow(10.0,value/cnt);

  fft_structure_function("tmpo2", "strf");
  ID=image_ID("strf");
  value = 0.0;
  cnt = 0;
  for(ii=1;ii<Dlim;ii++)
    for(jj=1;jj<Dlim;jj++)
      {
	value += log10(data.image[ID].array.F[jj*size+ii])-5.0/3.0*log10(sqrt(ii*ii+jj*jj)); 
	cnt++;
      }
  delete_image_ID("strf");
  C2 = pow(10.0,value/cnt);
  
  printf("%f %f\n", C1, C2);
  
  arith_image_cstmult("tmpo1",1.0/sqrt(C1),ID_name1);
  arith_image_cstmult("tmpo2",1.0/sqrt(C2),ID_name2);
  delete_image_ID("tmpo1");
  delete_image_ID("tmpo2");

  return(0);
}




int make_master_turbulence_screen_pow(char *ID_name1, char *ID_name2, long size, float power)
{
  long ID,ii,jj;
  float value,C1,C2;
  long cnt;
  long Dlim = 3;

  make_rnd("tmppha",size,size,"");
  arith_image_cstmult("tmppha",2.0*PI,"tmppha1");
  delete_image_ID("tmppha");
  make_dist("tmpd",size,size,size/2,size/2);
  make_rnd("tmpg",size,size,"-gauss");
  
  arith_image_cstpow("tmpd",power,"tmpd1");
  delete_image_ID("tmpd");
  arith_image_div("tmpg","tmpd1","tmpamp");
  delete_image_ID("tmpg");
  delete_image_ID("tmpd1");
  arith_set_pixel("tmpamp",0.0,size/2,size/2);
  mk_complex_from_amph("tmpamp","tmppha1","tmpc");
  delete_image_ID("tmpamp");
  delete_image_ID("tmppha1");
  permut("tmpc");
  do2dfft("tmpc","tmpcf");
  delete_image_ID("tmpc");
  mk_reim_from_complex("tmpcf","tmpo1","tmpo2");
  delete_image_ID("tmpcf");

  /* compute the scaling factor in the power law of the structure function */
  fft_structure_function("tmpo1","strf");
  ID=image_ID("strf");
  value = 0.0;
  cnt = 0;
  for(ii=1;ii<Dlim;ii++)
    for(jj=1;jj<Dlim;jj++)
      {
	value += log10(data.image[ID].array.F[jj*size+ii])-power*log10(sqrt(ii*ii+jj*jj)); 
	/*	printf("%ld %ld %f\n",ii,jj,log10(data.image[ID].array.F[jj*size+ii])-5.0/3.0*log10(sqrt(ii*ii+jj*jj)));*/
	cnt++;
      }
  delete_image_ID("strf");
  C1=pow(10.0,value/cnt);

  fft_structure_function("tmpo2","strf");
  ID=image_ID("strf");
  value = 0.0;
  cnt = 0;
  for(ii=1;ii<Dlim;ii++)
    for(jj=1;jj<Dlim;jj++)
      {
	value += log10(data.image[ID].array.F[jj*size+ii])-power*log10(sqrt(ii*ii+jj*jj)); 
	cnt++;
      }
  delete_image_ID("strf");
  C2=pow(10.0,value/cnt);
  /*  printf("%f %f\n",C1,C2);*/
  arith_image_cstmult("tmpo1",1.0/sqrt(C1),ID_name1);
  arith_image_cstmult("tmpo2",1.0/sqrt(C2),ID_name2);
  delete_image_ID("tmpo1");
  delete_image_ID("tmpo2");

  return(0);
}





int contract_wavefront_cube(char *ina_file, char *inp_file, char *outa_file, char *outp_file, int factor)
{
  /* contracts the wavefront series by a factor of 2^factor */
  long IDamp,IDpha,IDoutamp,IDoutpha;
  long ii,jj,kk;
  long i,j;
  long naxes[3];
  long naxes_out[3];
  float re, im, amp, pha;
  float P;
  long LARGE = 10000;
  float pharef, ampref;
  int pfactor;
  
  pfactor=1;
  for(i=0;i<factor;i++)
    pfactor *= 2;

  load_fits(inp_file,"tmpwfp");
  IDpha=image_ID("tmpwfp");
  load_fits(ina_file,"tmpwfa");
  IDamp=image_ID("tmpwfa");
  naxes[0] = data.image[IDpha].md[0].size[0];
  naxes[1] = data.image[IDpha].md[0].size[1];
  naxes[2] = data.image[IDpha].md[0].size[2];
  naxes_out[0] = data.image[IDpha].md[0].size[0]/pfactor;
  naxes_out[1] = data.image[IDpha].md[0].size[1]/pfactor;
  naxes_out[2] = data.image[IDpha].md[0].size[2];
  IDoutpha = create_3Dimage_ID("tmpwfop",naxes_out[0],naxes_out[1],naxes_out[2]);
  IDoutamp = create_3Dimage_ID("tmpwfoa",naxes_out[0],naxes_out[1],naxes_out[2]);
      
  ii=0;
  jj=0;
  kk=0;
  amp = 0.0;
  pha = 0.0;

  //  # ifdef _OPENMP
  //  #pragma omp parallel
  //  {
  //  # endif

    //  # ifdef _OPENMP
    //  #pragma omp for private(kk,ii,jj,i,j,amp,pha,ampref,pharef,re,im,P) collapse(3)
  //  # endif 
  for(kk=0;kk<naxes[2];kk++)
    {
      for(ii=0;ii<naxes[0]/pfactor;ii++)
	for(jj=0;jj<naxes[1]/pfactor;jj++)
	  {
	    re=0.0;
	    im=0.0;
	    pharef = 0.0;
	    ampref = 0.0;
	    for(i=0;i<pfactor;i++)
	      for(j=0;j<pfactor;j++)
		{
		  amp = data.image[IDamp].array.F[kk*naxes[0]*naxes[1]+(pfactor*jj+j)*naxes[0]+pfactor*ii+i];
		  pha = data.image[IDpha].array.F[kk*naxes[0]*naxes[1]+(pfactor*jj+j)*naxes[0]+pfactor*ii+i];
		  pharef += data.image[IDamp].array.F[kk*naxes[0]*naxes[1]+(pfactor*jj+j)*naxes[0]+pfactor*ii+i]*data.image[IDpha].array.F[kk*naxes[0]*naxes[1]+(pfactor*jj+j)*naxes[0]+pfactor*ii+i];
		  ampref += data.image[IDamp].array.F[kk*naxes[0]*naxes[1]+(pfactor*jj+j)*naxes[0]+pfactor*ii+i];
		  re += amp*cos(pha);
		  im += amp*sin(pha);
		}
	    amp = sqrt(re*re+im*im);
	    pha = atan2(im,re);
	    pharef /= ampref;
	    P = 2.0*PI*( ((long) (0.5+1.0*LARGE+(pharef-pha)/2.0/PI)) - LARGE);
	    if(ampref<0.01)
	      P = 0.0;
	    data.image[IDoutpha].array.F[kk*naxes_out[0]*naxes_out[1]+jj*naxes_out[0]+ii] = pha+P;
	    data.image[IDoutamp].array.F[kk*naxes_out[0]*naxes_out[1]+jj*naxes_out[0]+ii] = amp/pfactor/pfactor;
	  }
    }

  //  # ifdef _OPENMP
  //  }
  //  # endif


  save_fl_fits("tmpwfop",outp_file);
  save_fl_fits("tmpwfoa",outa_file);
  
  delete_image_ID("tmpwfa");
  delete_image_ID("tmpwfp");
  delete_image_ID("tmpwfoa");
  delete_image_ID("tmpwfop");


  return(0);
}


int contract_wavefront_cube_phaseonly(char *inp_file, char *outp_file, int factor)
{
  /* contracts the wavefront series by a factor of 2^factor */
  long IDpha,IDoutpha;
  long ii,jj,kk;
  long i,j;
  long naxes[3];
  long naxes_out[3];
  float re,im,amp,pha;
  float P;
  long LARGE = 10000;
  float pharef,ampref;
  int pfactor;
  long l1,l2,l3,l4;

  //  printf("CONTRACT, FACTOR = %d\n",factor);
  //fflush(stdout);

  pfactor=1;
  for(i=0;i<factor;i++)
    pfactor *= 2;  

  load_fits(inp_file,"tmpwfp");
  IDpha=image_ID("tmpwfp");
  naxes[0] = data.image[IDpha].md[0].size[0];
  naxes[1] = data.image[IDpha].md[0].size[1];
  naxes[2] = data.image[IDpha].md[0].size[2];
  naxes_out[0] = data.image[IDpha].md[0].size[0]/pfactor;
  naxes_out[1] = data.image[IDpha].md[0].size[1]/pfactor;
  naxes_out[2] = data.image[IDpha].md[0].size[2];
  IDoutpha = create_3Dimage_ID("tmpwfop",naxes_out[0],naxes_out[1],naxes_out[2]);
      
  ii=0;
  jj=0;
  kk=0;
  amp = 0.0;
  pha = 0.0;
  ampref = 1.0*pfactor*pfactor;

# ifdef _OPENMP
#pragma omp parallel for shared(naxes,naxes_out,data,pfactor,IDoutpha,IDpha,ampref) private(kk,ii,jj,i,j,amp,pha,pharef,re,im,P,l1,l2,l3,l4)
# endif 
  for(kk=0;kk<naxes[2];kk++)
    {
      l1 = kk*naxes_out[0]*naxes_out[1];
      l2 = kk*naxes[0]*naxes[1];
      for(ii=0;ii<naxes[0]/pfactor;ii++)
	for(jj=0;jj<naxes[1]/pfactor;jj++)
	  {
	    re=0.0;
	    im=0.0;
	    pharef = 0.0;
	    l4=l2+pfactor*ii;
	    for(j=0;j<pfactor;j++)
	      {
		l3=l4+(pfactor*jj+j)*naxes[0];
		for(i=0;i<pfactor;i++)
		  {
		    pha = data.image[IDpha].array.F[l3+i];
		    pharef += data.image[IDpha].array.F[l3+i];
		    re += cos(pha);
		    im += sin(pha);
		  }
	      }
	    /*	    amp = sqrt(re*re+im*im);*/
	    pha = atan2(im,re);
	    pharef /= ampref;
	    P = 2.0*PI*( ((long) (0.5+1.0*LARGE+(pharef-pha)/2.0/PI)) - LARGE);
	    if(ampref<0.01)
	      P = 0.0;
	    data.image[IDoutpha].array.F[l1+jj*naxes_out[0]+ii] = pha+P;
	  }

    }

  save_fl_fits("tmpwfop",outp_file);
  
  delete_image_ID("tmpwfp");
  delete_image_ID("tmpwfop");


  return(0);
}



int make_AtmosphericTurbulence_wavefront_series()
{
    long WFsize;
    //  fitsfile *fptr;       /* pointer to the FITS file; defined in fitsio.h */
    int status;
    long  fpixel = 1, naxis = 3, nelement;
    char KEYWORD[200];
    char CONTENT[200];
    float TIME_STEP;
    float TIME_SPAN;
    long NB_TSPAN;

    int WFOUTPUT = 1;
    int SHM_OUTPUT = 0;
    
    int SHM_SOUTPUT = 0;
    char SHM_SPREFIX[100];
    int SHM_SOUTPUTM = 0; // 1: output in [meter]
    
    char WF_FILE_PREFIX[100];
    float PUPIL_SCALE;
    float LAMBDA;
    long naxes_MASTER[2];
    /*  long ID;*/
    long ID1,ID2;
    long tspan;
    char fname_a[200];
    char fname1[200];
    char fname1_a[200];
    char fname2[200];
    char tmpafname[200];
    char tmppfname[200];

    float SODIUM_ALT;
    float layer_scale;

    int FRESNEL_PROPAGATION;
    int WAVEFRONT_AMPLITUDE;

    long MASTER_SIZE;
    long master;
    long NBMASTERS;
    long *ID_TM;
    long *ID_TML;
    long IDout_array_pha;
    long IDout_array_amp;
    complex_float *array;

    // phase only
    long ID_array1;
    long ID_sarray1;
    long ID_carray1;

    // phase + amplitude
    long ID_array2;
    long ID_sarray2;
    long ID_carray2;

    float re,im;

    int make_swavefront = 0;  /* 1 if the IR wavefront should also be made */
    float SLAMBDA;
    char SWF_FILE_PREFIX[100];
    int SWF_WRITE2DISK;
    long IDout_sarray_pha;
    long IDout_sarray_amp;
    complex_float *sarray;
    float Scoeff;
    float Nlambda,Nslambda, l;


    int make_cwavefront = 0; /* 1 if the cone effect wavefront shoule be also made */
    char CWF_FILE_PREFIX[100];
    complex_float *carray;


    long NBLAYERS; /* number of layers */
    long layer;
    FILE *fp;
    char command[200];
    char line[2000];
    char word[200];
    char fname[200];
    float *LAYER_ALT;
    float *LAYER_CN2;
    float *LAYER_SPD;
    float *LAYER_DIR;
    float *LAYER_OUTERSCALE;
    float *LAYER_INNERSCALE;
     int stop;

    long *naxes;
    long *naxesout;
    double *xpos;
    double *ypos;
    double *xpos0;
    double *ypos0;
    long *xposfcnt; // counter to keep trak of modulo
    long *yposfcnt;
	float *vxpix;
    float *vypix;
    double vpix,PA;
    long vindex;
    long frame;
    long NBFRAMES;
    float fl1, fl2, fl3, fl4, fl5, fl6;
    long ii, jj, iim, jjm, ii1, jj1;
    float value;
    float coeff=0.0;

    float Fresnel_alt_bin; /* in m */
    float *alt_bin_sep;
    long NB_alt_bin_sep;
    float minaltd;
    float *SLAYER_ALT;
    float *SLAYER_CN2;
    long NBSLAYERS;
    int OK;
    long i,j,index;
    long *super_layer_index;

    int contraction_factor;
    int pfactor;
    float seeing;
    float Zangle;
    float SOURCE_Xpos;
    float SOURCE_Ypos;
 //   float OuterScale;
    float CN2total;
    float tmp,tmpf,h,Rindex,Roffset,RoffsetS;

    long xref,yref,xrefm,yrefm,iimax,jjmax,y1;
    long ID;
    long start_tspan=0;

    double tot,p1,p2,tmp1;
    long dpix,cnt,k,r0cnt;
    double r0,r0tot;

    int SKIP_EXISTING;

    long IDshmpha, IDshmamp;
    long IDshmspha, IDshmsamp;

    //
    // US standard atmosphere density, normalized to sea level, 2km step
    // log10 of density, 2km step
    //
    double StdAtmDens[44] = {0.000000, -0.085107, -0.174693, -0.268526, -0.367316, -0.471661, -0.594121, -0.730392, -0.866722, -1.003203, -1.139185, -1.278509, -1.416593, -1.553349, -1.688809, -1.823082, -1.956197, -2.093072, -2.227379, -2.358485, -2.486619, -2.611739, -2.734220, -2.854125, -2.968550, -3.076566, -3.182071, -3.282703, -3.385361, -3.490222, -3.597335, -3.706660, -3.818623, -3.933104, -4.050311, -4.170053, -4.293230, -4.421899, -4.552842, -4.686219, -4.822140, -4.960707, -5.101812, -5.245839};

    double logD;
    double x;
    long i0,i1;
    double iimf, jjmf, iifrac, jjfrac, value_re, value_im;
    long iim1, jjm1;
    double pha;

    int r;



	// timing
	long SIMTDELAY = 0; // [us]
	int ATMWF_REALTIME = 0;
	double ATMWF_REALTIMEFACTOR = 1.0;
	struct timespec tnow;
	double tnowdouble;
	int kw;






    naxes = (long*) malloc(sizeof(long)*3);
    naxesout = (long*) malloc(sizeof(long)*3);



    ID1=-1;
    ID2=-1;
    ID_sarray1=-1;
    sarray = NULL;
    ID_carray1=-1;
    carray = NULL;






    printf("Making the wavefront series...\n");
    fflush(stdout);



    strcpy(KEYWORD,"SKIP_EXISTING");
    if(read_config_parameter_exists(CONFFILE,KEYWORD)==1)
    {
        read_config_parameter(CONFFILE,KEYWORD,CONTENT);
        SKIP_EXISTING = 1;
    }
    else
        SKIP_EXISTING = 0;



    strcpy(KEYWORD,"TURBULENCE_SEEING");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    seeing = atof(CONTENT);

    strcpy(KEYWORD,"ZENITH_ANGLE");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    Zangle = atof(CONTENT);

    strcpy(KEYWORD,"SOURCE_XPOS");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    SOURCE_Xpos = atof(CONTENT);

    strcpy(KEYWORD,"SOURCE_YPOS");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    SOURCE_Ypos = atof(CONTENT);

    strcpy(KEYWORD,"SITE_ALT");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    SiteAlt = atof(CONTENT);

   strcpy(KEYWORD,"SITE_TPW");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    SiteTPW = atof(CONTENT);

   strcpy(KEYWORD,"SITE_PW_SCALEH");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    SitePWSH = atof(CONTENT);


    strcpy(KEYWORD,"PUPIL_SCALE");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    PUPIL_SCALE = atof(CONTENT);

    strcpy(KEYWORD,"PUPIL_AMPL_FILE");
    if(read_config_parameter_exists(CONFFILE,KEYWORD)==1)
    {
        read_config_parameter(CONFFILE,KEYWORD,CONTENT);
        load_fits(CONTENT,"ST_pa");
    }

    strcpy(KEYWORD,"PUPIL_PHA_FILE");
    if(read_config_parameter_exists(CONFFILE,KEYWORD)==1)
    {
        read_config_parameter(CONFFILE,KEYWORD,CONTENT);
        load_fits(CONTENT,"ST_pp");
    }

    strcpy(KEYWORD,"TURBULENCE_REF_WAVEL");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    LAMBDA = atof(CONTENT)*0.000001;

    strcpy(KEYWORD,"SODIUM_LAYER_ALTITUDE");
    if(read_config_parameter_exists(CONFFILE,KEYWORD)==1)
    {
        read_config_parameter(CONFFILE,KEYWORD,CONTENT);
        SODIUM_ALT = 1000.0*atof(CONTENT);
    }
    else
        SODIUM_ALT = 90.0*1000.0;

    strcpy(KEYWORD,"FRESNEL_PROPAGATION");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    FRESNEL_PROPAGATION = atoi(CONTENT);

    strcpy(KEYWORD,"WAVEFRONT_AMPLITUDE");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    WAVEFRONT_AMPLITUDE = atoi(CONTENT);

    strcpy(KEYWORD,"MAKE_SWAVEFRONT");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    make_swavefront = atoi(CONTENT);
    strcpy(KEYWORD,"SLAMBDA");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    SLAMBDA = atof(CONTENT)*0.000001;
    strcpy(KEYWORD,"SWF_FILE_PREFIX");
    read_config_parameter(CONFFILE,KEYWORD,SWF_FILE_PREFIX);

    strcpy(KEYWORD,"SWF_WRITE2DISK");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    SWF_WRITE2DISK = atoi(CONTENT);



    strcpy(KEYWORD,"MAKE_CWAVEFRONT");
    if(read_config_parameter_exists(CONFFILE,KEYWORD)==1)
    {
        read_config_parameter(CONFFILE,KEYWORD,CONTENT);
        make_cwavefront = atoi(CONTENT);
    }
    else
        make_cwavefront = 0;


    strcpy(KEYWORD,"CWF_FILE_PREFIX");
    if(read_config_parameter_exists(CONFFILE,KEYWORD)==1)
        read_config_parameter(CONFFILE,KEYWORD,CWF_FILE_PREFIX);
    else
        sprintf(CWF_FILE_PREFIX,"cwf_");




//	printf("Building reference atmoshpere model ...\n");
	AtmosphericTurbulence_build_stdAtmModel("atm.txt");

//	exit(0);

	fp = fopen("Rprof.txt", "w");
	for(h=0;h<10000.0;h+=10.0)
		fprintf(fp, "%8g %.16f %.16f\n", h, AtmosphericTurbulence_stdAtmModel_N(h, 0.6), AtmosphericTurbulence_stdAtmModel_N(h, 1.6));
	fclose(fp);

	fp = fopen("Rlambda.txt", "w");
	for(l=0.4;l<2.0;l+=0.01)
		fprintf(fp, "%.16f %.16f %.16f\n", l, AtmosphericTurbulence_stdAtmModel_N(1000, l), AtmosphericTurbulence_stdAtmModel_N(4200, l));
	fclose(fp);

	

	//exit(0);








//    Scoeff = LAMBDA/SLAMBDA;
 //   Nlambda = 0.0000834213+0.0240603/(130.0-1.0/pow(LAMBDA*1000000.0,2.0))+0.00015997/(38.9-1.0/pow(LAMBDA*1000000.0,2.0));
 //   Nslambda = 0.0000834213+0.0240603/(130.0-1.0/pow(SLAMBDA*1000000.0,2.0))+0.00015997/(38.9-1.0/pow(SLAMBDA*1000000.0,2.0));

	//printf("method 1 : %f %f\n", Nlambda, Nslambda);

    Nlambda = AtmosphericTurbulence_stdAtmModel_N(0.0, LAMBDA*1000000.0);
    Nslambda = AtmosphericTurbulence_stdAtmModel_N(0.0, SLAMBDA*1000000.0);
    Scoeff =  LAMBDA/SLAMBDA * Nslambda/Nlambda; // multiplicative coefficient to go from reference lambda phase to science lambda phase


  //  printf("Scoeff is %f (%f)\n",Scoeff,Nslambda/Nlambda);
 //   fflush(stdout);


   // printf("Zenith angle = %f rad\n", Zangle);


    strcpy(KEYWORD,"SWF_FILE_PREFIX");
    read_config_parameter(CONFFILE,KEYWORD,SWF_FILE_PREFIX);
    Fresnel_alt_bin = atof(CONTENT);

    strcpy(KEYWORD,"WFsize");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    WFsize = atol(CONTENT);
    naxesout[0] = WFsize;
    naxesout[1] = WFsize;

    strcpy(KEYWORD,"WF_RAW_SIZE");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    naxes[0]=atol(CONTENT);
    naxes[1]=atol(CONTENT);

    //  pfactor = naxes[0]/WFsize;
    pfactor = 1;
    contraction_factor = 4;
    if(naxes[0]/WFsize==1)
        contraction_factor = 0;
    if(naxes[0]/WFsize==2)
        contraction_factor = 1;
    if(naxes[0]/WFsize==4)
        contraction_factor = 2;
    if(naxes[0]/WFsize==8)
        contraction_factor = 3;

    if(contraction_factor==4)
    {
        printf("ERROR: unknown contraction factor\n");
        fflush(stdout);
        exit(0);
    }

    /*  ID=image_ID("ST_pa");*/

	strcpy(KEYWORD,"SIMTDELAY");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    SIMTDELAY = atol(CONTENT);


	strcpy(KEYWORD,"REALTIME");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    ATMWF_REALTIME = atoi(CONTENT);
	strcpy(KEYWORD,"REALTIMEFACTOR");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    ATMWF_REALTIMEFACTOR = atof(CONTENT);



    strcpy(KEYWORD,"WFTIME_STEP");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    TIME_STEP = atof(CONTENT);
    strcpy(KEYWORD,"TIME_SPAN");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    TIME_SPAN = atof(CONTENT);
    strcpy(KEYWORD,"NB_TSPAN");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    NB_TSPAN = atol(CONTENT);


    strcpy(KEYWORD,"WFOUTPUT");
    if(read_config_parameter_exists(CONFFILE,KEYWORD)==1)
    {
        read_config_parameter(CONFFILE,KEYWORD,CONTENT);
        WFOUTPUT = atoi(CONTENT);
    }


    strcpy(KEYWORD,"WF_FILE_PREFIX");
    read_config_parameter(CONFFILE,KEYWORD,WF_FILE_PREFIX);


    strcpy(KEYWORD,"SHM_OUTPUT");
    if(read_config_parameter_exists(CONFFILE,KEYWORD)==1)
    {
        read_config_parameter(CONFFILE,KEYWORD,CONTENT);
        SHM_OUTPUT = atoi(CONTENT);
    }

    strcpy(KEYWORD,"SHM_SOUTPUT");
    if(read_config_parameter_exists(CONFFILE,KEYWORD)==1)
    {
        read_config_parameter(CONFFILE,KEYWORD,CONTENT);
        SHM_SOUTPUT = atoi(CONTENT);
    }
   strcpy(KEYWORD,"SHM_SPREFIX");
    read_config_parameter(CONFFILE,KEYWORD, SHM_SPREFIX);
   
	strcpy(KEYWORD,"SHM_SOUTPUTM");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    SHM_SOUTPUTM = atoi(CONTENT);






    NBFRAMES = (long) (TIME_SPAN/TIME_STEP);
    naxes[2] = NBFRAMES;
    naxesout[2] = NBFRAMES;

    nelement = naxes[0] * naxes[1] * naxes[2];
    printf("Allocating memory...\n");
    fflush(stdout);

    // OUTPUT ARRAYS
    IDout_array_pha = create_3Dimage_ID("outarraypha",naxesout[0],naxesout[1],naxesout[2]);
    IDout_array_amp = create_3Dimage_ID("outarrayamp",naxesout[0],naxesout[1],naxesout[2]);
    IDout_sarray_pha = create_3Dimage_ID("outsarraypha",naxesout[0],naxesout[1],naxesout[2]);
    IDout_sarray_amp = create_3Dimage_ID("outsarrayamp",naxesout[0],naxesout[1],naxesout[2]);

    //  array_pha = (float*) malloc(naxesout[2]*naxesout[1]*naxesout[0]*sizeof(float));
    //  array_amp = (float*) malloc(naxesout[2]*naxesout[1]*naxesout[0]*sizeof(float));
    //  sarray_pha = (float*) malloc(naxesout[2]*naxesout[1]*naxesout[0]*sizeof(float));
    //  sarray_amp = (float*) malloc(naxesout[2]*naxesout[1]*naxesout[0]*sizeof(float));
    //  printf("Memory allocated\n");
    //  fflush(stdout);
    for(ii=0; ii<naxesout[0]*naxesout[1]*naxesout[2]; ii++)
    {
        data.image[IDout_array_amp].array.F[ii] = 1.0;
        data.image[IDout_array_pha].array.F[ii] = 0.0;

        data.image[IDout_sarray_amp].array.F[ii] = 1.0;
        data.image[IDout_sarray_pha].array.F[ii] = 0.0;
    }


    strcpy(KEYWORD,"MASTER_SIZE");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    MASTER_SIZE = atol(CONTENT);
    naxes_MASTER[0] = MASTER_SIZE;
    naxes_MASTER[1] = MASTER_SIZE;

    master=0;
    stop=1;
    while(stop)
    {
        sprintf(fname,"t%ld_%ld",master,MASTER_SIZE);
        if(!file_exists(fname))
        {
            stop=0;
        }
        else
            master++;
    }

    NBMASTERS = master;
    printf("%ld turbulence master files\n",NBMASTERS);
    fflush(stdout);

    strcpy(KEYWORD,"TURBULENCE_PROF_FILE");
    read_config_parameter(CONFFILE,KEYWORD,CONTENT);
    if((fp=fopen(CONTENT,"r"))==NULL)
    {
        printf("Cannot open turbulence profile file \"%s\"\n",CONTENT);
        exit(1);
    }
    NBLAYERS=0;
    while(fgets(line,2000,fp)!=NULL)
    {
        sscanf(line,"%s",word);
        if(isdigit(word[0]))
        {
            NBLAYERS+=1;
        }
    }
    fclose(fp);

    LAYER_ALT = (float*) malloc(NBLAYERS*sizeof(float));
    LAYER_CN2 = (float*) malloc(NBLAYERS*sizeof(float));
    LAYER_SPD = (float*) malloc(NBLAYERS*sizeof(float));
    LAYER_DIR = (float*) malloc(NBLAYERS*sizeof(float));
    LAYER_OUTERSCALE = (float*) malloc(NBLAYERS*sizeof(float));
    LAYER_INNERSCALE = (float*) malloc(NBLAYERS*sizeof(float));
   if((fp=fopen(CONTENT,"r"))==NULL)
    {
        printf("Cannot open turbulence profile file \"%s\"\n",CONTENT);
        exit(1);
    }
    layer=0;
    while(fgets(line,2000,fp)!=NULL)
    {
        sscanf(line,"%s",word);
        if(isdigit(word[0]))
        {
            sscanf(line,"%f %f %f %f %f %f", &fl1, &fl2, &fl3, &fl4, &fl5, &fl6);
            if(fl1>SiteAlt-0.1)
            {
                LAYER_ALT[layer] = fl1;
                LAYER_CN2[layer] = fl2;
                LAYER_SPD[layer] = fl3;
                LAYER_DIR[layer] = fl4;
                LAYER_OUTERSCALE[layer] = fl5;
                LAYER_INNERSCALE[layer] = fl6;
                layer+=1;
            }
        }
    }
    fclose(fp);

    /* CN2 normalisation for 1024x1024 -> 256x256*/
    /* S<0.7 : x=(S-0.1)/0.06*2
    S>0.7 : x=(S-0.38)/0.033*2 */
    /*  if(seeing<0.7)
    CN2total = (seeing-0.1)/0.03;
    else
    CN2total = (seeing-0.38)/0.0165;*/
    /* S  = sqrt(CN2/16.666)*0.443 = 0.1085 sqrt(CN2) */

    CN2total = 1.0; //84.926*seeing*seeing;

    tmp = 0;
    for(layer=0; layer<NBLAYERS; layer++)
        tmp += LAYER_CN2[layer];
    for(layer=0; layer<NBLAYERS; layer++)
        LAYER_CN2[layer] *= CN2total/tmp;



    for(layer=0; layer<NBLAYERS; layer++)
    {
        printf("Turbulence layer %ld : alt = %f m   CN2 = %f   V = %f m/s   Angle = %f rad   outerscale = %f m    innerscale = %f m\n",layer,LAYER_ALT[layer],LAYER_CN2[layer],LAYER_SPD[layer],LAYER_DIR[layer], LAYER_OUTERSCALE[layer], LAYER_INNERSCALE[layer]);
    }

    SLAYER_ALT = (float*) malloc(NBLAYERS*sizeof(float));
    SLAYER_CN2 = (float*) malloc(NBLAYERS*sizeof(float));
    NBSLAYERS = NBLAYERS;
    for(layer=0; layer<NBSLAYERS; layer++)
    {
        SLAYER_ALT[layer] = LAYER_ALT[layer];
        SLAYER_CN2[layer] = LAYER_CN2[layer];
    }

    OK=0;
    while(OK==0)
    {
        printf("--------------------\n");
        for(i=0; i<NBSLAYERS; i++)
            printf("Super layer %ld/%ld  alt: %f  CN2: %f\n", i, NBSLAYERS,SLAYER_ALT[i], SLAYER_CN2[i]);

        /* look for minimum altitude difference */
        minaltd = LAYER_ALT[NBLAYERS-1];
        index = 0;
        for(i=0; i<NBSLAYERS-1; i++)
        {
            value = SLAYER_ALT[i+1]-SLAYER_ALT[i];
            if(value<minaltd)
            {
                minaltd=value;
                index = i;
            }
        }
        if((minaltd>Fresnel_alt_bin)||(NBSLAYERS==1))
        {
            OK=1;
        }
        else
        {
            /* group SLAYERs i and i+1 */
            printf("Group slayers %ld and %ld\n",index,index+1);
            SLAYER_ALT[index] = (SLAYER_CN2[index]*SLAYER_ALT[index]+SLAYER_CN2[index+1]*SLAYER_ALT[index+1])/(SLAYER_CN2[index]+SLAYER_CN2[index+1]);
            SLAYER_CN2[index] = SLAYER_CN2[index] + SLAYER_CN2[index+1];
            for(i=index+1; i<NBSLAYERS-1; i++)
            {
                SLAYER_ALT[i] = SLAYER_ALT[i+1];
                SLAYER_CN2[i] = SLAYER_CN2[i+1];
            }
            NBSLAYERS-=1;
        }
    }
    for(i=0; i<NBSLAYERS; i++)
    {
        printf("Super layer %ld  alt: %f  CN2: %g\n",i,SLAYER_ALT[i],SLAYER_CN2[i]);
    }

    NB_alt_bin_sep = NBSLAYERS-1;
    alt_bin_sep = (float*) malloc(NB_alt_bin_sep*sizeof(float));
    for(i=0; i<NB_alt_bin_sep; i++)
    {
        alt_bin_sep[i] = 0.5*(SLAYER_ALT[i]+SLAYER_ALT[i+1]);
        printf("Altitude bin separation %ld is %f\n",i,alt_bin_sep[i]);
    }

    free(SLAYER_CN2);

    super_layer_index = (long*) malloc(NBLAYERS*sizeof(long));
    for(layer=0; layer<NBLAYERS; layer++)
    {
        index=0;
        for(i=0; i<NB_alt_bin_sep; i++)
            if((alt_bin_sep[i]<LAYER_ALT[layer])&&(alt_bin_sep[i+1]>LAYER_ALT[layer]))
                index=i+1;
        if(LAYER_ALT[layer]>alt_bin_sep[NB_alt_bin_sep-1])
            index = NB_alt_bin_sep;
        super_layer_index[layer]=index;
        printf("Layer %ld belongs to superlayer %ld/%ld\n",layer,super_layer_index[layer],NBSLAYERS);
    }


    frame=0;
    xpos = (double*) malloc(sizeof(double)*NBLAYERS);
    ypos = (double*) malloc(sizeof(double)*NBLAYERS);
    xpos0 = (double*) malloc(sizeof(double)*NBLAYERS);
    ypos0 = (double*) malloc(sizeof(double)*NBLAYERS);
	xposfcnt = (long*) malloc(sizeof(long)*NBLAYERS);
	yposfcnt = (long*) malloc(sizeof(long)*NBLAYERS);

	vxpix = (float*) malloc(sizeof(float)*NBLAYERS);
    vypix = (float*) malloc(sizeof(float)*NBLAYERS);


    printf("Computing refraction and position offset for Zangle = %f\n",Zangle);
    for(layer=0; layer<NBLAYERS; layer++)
    {
		xposfcnt[layer] = 0;
		yposfcnt[layer] = 0;
	
        xpos[layer] = 0.05*MASTER_SIZE;
        ypos[layer] = 0.05*MASTER_SIZE;
        
        // layer shift due to atmospheric refraction
        // we compute here what the offset is at a the reference wavelength
        Roffset = 0.0;
        for(h=SiteAlt; h<LAYER_ALT[layer]; h += 1.0)
        {
            Rindex = 1.0 + AtmosphericTurbulence_stdAtmModel_N(h, LAMBDA*1000000.0);
            tmpf = sin(Zangle)/sqrt(Rindex*Rindex-sin(Zangle)*sin(Zangle));
            tmpf -= sin(Zangle)/sqrt(1.0-sin(Zangle)*sin(Zangle));
            Roffset += tmpf;
        }

		// we compute here the offset at the science wavelength
        RoffsetS = 0.0;
        for(h=SiteAlt; h<LAYER_ALT[layer]; h += 1.0)
        {
			Rindex = 1.0 + AtmosphericTurbulence_stdAtmModel_N(h, SLAMBDA*1000000.0);
            tmpf = sin(Zangle)/sqrt(Rindex*Rindex-sin(Zangle)*sin(Zangle));
            tmpf -= sin(Zangle)/sqrt(1.0-sin(Zangle)*sin(Zangle));
            RoffsetS += tmpf;
        }
		
		// the refractive offset is the difference between the reference and science wavelength offsets
        ypos[layer] += (RoffsetS-Roffset)/(PUPIL_SCALE/pfactor);

		// add here offset due to source position
		// SOURCE_Xpos and SOURCE_Ypos are in radian
		xpos[layer] += SOURCE_Xpos*LAYER_ALT[layer]/(PUPIL_SCALE/pfactor);
		ypos[layer] += SOURCE_Ypos*LAYER_ALT[layer]/(PUPIL_SCALE/pfactor);

		xpos0[layer] = SOURCE_Xpos*LAYER_ALT[layer]/(PUPIL_SCALE/pfactor); // for realtime mode
		ypos0[layer] = SOURCE_Ypos*LAYER_ALT[layer]/(PUPIL_SCALE/pfactor);

        vxpix[layer] = LAYER_SPD[layer]*cos(LAYER_DIR[layer])/(PUPIL_SCALE/pfactor); /* pixel coordinate speed, in pixel per sec, x axis */
        vypix[layer] = LAYER_SPD[layer]*sin(LAYER_DIR[layer])/(PUPIL_SCALE/pfactor); /* pixel coordinate speed, in pixel per sec, y axis */

        printf("------ layer %ld, SPEED = %f x %f pix/step, offset = %f m ----------\n",layer,vxpix[layer],vypix[layer],RoffsetS-Roffset);
    }


    printf("NBMASTERS = %ld\n",NBMASTERS);
    if(NBMASTERS<NBLAYERS)
        NBMASTERS = NBLAYERS;
    ID_TM = (long*) malloc(sizeof(long)*NBMASTERS);
    for(i=0; i<NBMASTERS; i++)
    {
        sprintf(fname,"t%ld_%ld",i,MASTER_SIZE);
        sprintf(fname1,"TM%ld",i);
        if(load_fits(fname,fname1)==-1)
        {
            sprintf(fname,"t%ld_%ld",i,MASTER_SIZE);
            sprintf(fname1,"TM%ld",i);
            printf("CREATING %s   (%f - %f)\n", fname, LAYER_OUTERSCALE[i]/PUPIL_SCALE, LAYER_INNERSCALE[i]/PUPIL_SCALE);
            make_master_turbulence_screen(fname1, "tursctmp", MASTER_SIZE, LAYER_OUTERSCALE[i]/PUPIL_SCALE, LAYER_INNERSCALE[i]/PUPIL_SCALE);
            save_fl_fits(fname1, fname);
			delete_image_ID("tursctmp");
        }
        ID_TM[i] = image_ID(fname1);
    }
    ID_TML = (long*) malloc(sizeof(long)*NBLAYERS);
    j=0;
    for(i=0; i<NBLAYERS; i++)
    {
        ID_TML[i] = ID_TM[j];
        if(j==NBMASTERS)
        {
            printf("ERROR: number of master turbulence phase screens (%ld) is too small\n",NBMASTERS);
            exit(0);
        }
        j++;
    }







    // Measure r0 (pix) for each master turbulence screen
    dpix = 50;
    r0tot = 0.0;
    r0cnt = 0;
    for(k=0; k<NBMASTERS; k++)
    {
        cnt = 0;
        tot = 0.0;
        for(ii=0; ii<MASTER_SIZE-dpix; ii++)
            for(jj=0; jj<MASTER_SIZE; jj++)
            {
                p1 = data.image[ID_TM[k]].array.F[jj*MASTER_SIZE+ii];
                p2 = data.image[ID_TM[k]].array.F[jj*MASTER_SIZE+ii+dpix];
                tot += (p1-p2)*(p1-p2);
                cnt++;
            }
        r0 = 1.0*dpix*pow((tot/cnt)/6.88,-3.0/5.0);
        printf("TURBULENCE MASTER %ld    r0 = %g pix\n",k,r0);
        r0tot += r0;
        r0cnt++;
    }
    r0 = r0tot/r0cnt;
    printf("r0 = %g pix -> %g pix\n", r0, LAMBDA/(seeing/3600.0/180.0*PI)/PUPIL_SCALE*pfactor);

    // renormalize turbulence screens such that a single screen has the right r0
    tmp1 = pow(r0/(LAMBDA/(seeing/3600.0/180.0*PI)/PUPIL_SCALE*pfactor),5.0/6.0);
    for(k=0; k<NBMASTERS; k++)
        for(ii=0; ii<MASTER_SIZE*MASTER_SIZE; ii++)
            data.image[ID_TM[k]].array.F[ii] *= tmp1;

    r0tot = 0.0;
    r0cnt = 0;
    for(k=0; k<NBMASTERS; k++)
    {
        cnt = 0;
        tot = 0.0;
        for(ii=0; ii<MASTER_SIZE-dpix; ii++)
            for(jj=0; jj<MASTER_SIZE; jj++)
            {
                p1 = data.image[ID_TM[k]].array.F[jj*MASTER_SIZE+ii];
                p2 = data.image[ID_TM[k]].array.F[jj*MASTER_SIZE+ii+dpix];
                tot += (p1-p2)*(p1-p2);
                cnt++;
            }
        r0 = 1.0*dpix*pow((tot/cnt)/6.88,-3.0/5.0);
        printf("TURBULENCE MASTER %ld    r0 = %g pix\n",k,r0);
        r0tot += r0;
        r0cnt++;
    }
    r0 = r0tot/r0cnt;
    printf("r0 = %g pix\n",r0);


    // target seeing = seeing [arcsec]
    // ref lambda = LAMBDA [m]
    // if single screen:
    // r0[m] = LAMBDA[m]/seeing[rad]
    // r0[pix] = LAMBDA*1.0e-6/(seeing/3600.0/180.0*PI)/PUPIL_SCALE
    // multiply by (r0/r0goal)^6/5


    // each layer coeff mult by sqrt(fracCN2/cos(Zangle)))


    for(i=0; i<NBLAYERS; i++)
    {
        //      coeff = 3.645*183.8115*pow(10.0,-12)/LAMBDA/LAMBDA*PUPIL_SCALE*PUPIL_SCALE*sqrt(LAYER_CN2[i]);
        //if(pfactor==2)
        //	coeff *= 1.0/(pfactor*pfactor*pfactor*pfactor*pfactor*pfactor);
        for(ii=0; ii<MASTER_SIZE*MASTER_SIZE; ii++)
            data.image[ID_TML[i]].array.F[ii] *= sqrt(LAYER_CN2[i]/cos(Zangle));
        printf("Layer %ld, coeff = %g\n",i,sqrt(LAYER_CN2[i]/cos(Zangle)));
    }

 
 
 
    ID_array1 = create_2Dimage_ID("array1",naxes[0],naxes[1]);
    if(make_swavefront==1)
        ID_sarray1 = create_2Dimage_ID("sarray1",naxes[0],naxes[1]);
    if(make_cwavefront==1)
        ID_carray1 = create_2Dimage_ID("carray1",naxes[0],naxes[1]);



    if(WAVEFRONT_AMPLITUDE==1) // includes sub pixel translation
    {
        ID_array2 = create_2DCimage_ID("array2", naxes[0], naxes[1]);
        if(make_swavefront==1)
            ID_sarray2 = create_2DCimage_ID("sarray2", naxes[0], naxes[1]);
        if(make_cwavefront==1)
            ID_carray2 = create_2DCimage_ID("carray2", naxes[0], naxes[1]);
    }


    if((array = (complex_float*) malloc(NBFRAMES*naxes[0]*naxes[1]*sizeof(complex_float)))==NULL)
    {
        printf("Memory allocation error (\"array\" in make_AtmosphericTurbulence_wavefront_series)\n");
        printf("Decrease the size of the wavefront cube\n");
        exit(0);
    }

    if(make_swavefront==1)
    {
        if((sarray = (complex_float*) malloc(NBFRAMES*naxes[0]*naxes[1]*sizeof(complex_float)))==NULL)
        {
            printf("Memory allocation error (\"sarray\" in make_AtmosphericTurbulence_wavefront_series)\n");
            printf("Decrease the size of the wavefront cube\n");
            exit(0);
        }
    }

    if(make_cwavefront==1)
    {
        if((carray = (complex_float*) malloc(NBFRAMES*naxes[0]*naxes[1]*sizeof(complex_float)))==NULL)
        {
            printf("Memory allocation error (\"carray\" in make_AtmosphericTurbulence_wavefront_series)\n");
            printf("Decrease the size of the wavefront cube\n");
            exit(0);
        }
    }




    if(SHM_OUTPUT == 1)
    {
        IDshmpha = create_image_ID("atmwfpha", 2, naxesout, FLOAT, 1, 0);
        IDshmamp = create_image_ID("atmwfamp", 2, naxesout, FLOAT, 1, 0);
    }


    if(SHM_SOUTPUT == 1)
    {
		sprintf(fname, "%spha", SHM_SPREFIX);
        IDshmspha = create_image_ID(fname, 2, naxesout, FLOAT, 1, 0);
  		sprintf(fname, "%samp", SHM_SPREFIX);
		IDshmsamp = create_image_ID(fname, 2, naxesout, FLOAT, 1, 0);
    
		kw = 0;
		strcpy(data.image[IDshmspha].kw[kw].name, "TIME");	
		data.image[IDshmspha].kw[kw].type = 'D';
		data.image[IDshmspha].kw[kw].value.numf = 0.0;
		strcpy(data.image[IDshmspha].kw[kw].comment, "Physical time [sec]");
    
  		kw = 0;
		strcpy(data.image[IDshmsamp].kw[kw].name, "TIME");	
		data.image[IDshmsamp].kw[kw].type = 'D';
		data.image[IDshmsamp].kw[kw].value.numf = 0.0;
		strcpy(data.image[IDshmsamp].kw[kw].comment, "Physical time [sec]");
    }




    printf("SKIP_EXISTING = %d\n",SKIP_EXISTING);
    if(SKIP_EXISTING==1)
    {
        start_tspan = 0;
        OK = 1;
        while(OK==1)
        {
            sprintf(fname1,"%s%08ld.pha",WF_FILE_PREFIX,start_tspan);
            sprintf(fname2,"%s%08ld.pha",SWF_FILE_PREFIX,start_tspan);
            printf("TESTING FILE %s %s ... ", fname1, fname2);
            if(file_exists(fname1)==1)
            {
                start_tspan ++;
                printf("exists\n");
                OK = 1;
            }
            else
            {
                printf("does not exist\n");
                OK = 0;
            }
        }
    }
    printf("Start TSPAN = %ld\n",start_tspan);





    vindex = 0;


/*
        for(frame=0; frame<NBFRAMES; frame++)
        {
            vindex ++;
            for(layer=NBLAYERS-1; layer!=-1; layer--)
            {
                // random speed motion
                vpix = 0.0; //0.01*sin(11.0*vindex*(layer+3))*sqrt(vxpix[layer]*vxpix[layer]+vypix[layer]*vypix[layer]);
                PA = sin(10.0*vindex*(layer+2));

                xpos[layer] += vxpix[layer] + vpix*cos(PA);
                ypos[layer] += vypix[layer] + vpix*sin(PA);

                while(xpos[layer]<0)
                    xpos[layer] += 1.0*naxes_MASTER[0];
                while(xpos[layer]>1.0*naxes_MASTER[0])
                    xpos[layer] -= 1.0*naxes_MASTER[0];
                while(ypos[layer]<0)
                    ypos[layer] += 1.0*naxes_MASTER[1];
                while(ypos[layer]>1.0*naxes_MASTER[1])
                    ypos[layer] -= 1.0*naxes_MASTER[1];
            }
        }
  */  


    printf("WAVEFRONT_AMPLITUDE = %d\n", WAVEFRONT_AMPLITUDE);
    // exit(0);

	

    for(tspan=start_tspan; tspan<NB_TSPAN; tspan++)
    {
        for(frame=0; frame<NBFRAMES; frame++)
        {
            vindex ++;
            if(make_swavefront==1)
            {
                for(ii=0; ii<naxes[0]; ii++)
                    for(jj=0; jj<naxes[1]; jj++)
                    {
                        data.image[ID_array1].array.F[jj*naxes[0]+ii] = 0.0;
                        data.image[ID_sarray1].array.F[jj*naxes[0]+ii] = 0.0;
                    }
                if(WAVEFRONT_AMPLITUDE==1)
                    for(ii=0; ii<naxes[0]; ii++)
                        for(jj=0; jj<naxes[1]; jj++)
                        {
                            data.image[ID_array2].array.CF[jj*naxes[0]+ii].re = 1.0;
                            data.image[ID_array2].array.CF[jj*naxes[0]+ii].im = 0.0;
                            data.image[ID_sarray2].array.CF[jj*naxes[0]+ii].re = 1.0;
                            data.image[ID_sarray2].array.CF[jj*naxes[0]+ii].im = 0.0;
                        }
            }
            else
            {
                for(ii=0; ii<naxes[0]; ii++)
                    for(jj=0; jj<naxes[1]; jj++)
                        data.image[ID_array1].array.F[jj*naxes[0]+ii] = 0.0;
                if(WAVEFRONT_AMPLITUDE==1)
                    for(ii=0; ii<naxes[0]; ii++)
                        for(jj=0; jj<naxes[1]; jj++)
                        {
                            data.image[ID_array2].array.CF[jj*naxes[0]+ii].re = 1.0;
                            data.image[ID_array2].array.CF[jj*naxes[0]+ii].im = 0.0;
                        }
            }

            if(make_cwavefront==1)
            {
                for(ii=0; ii<naxes[0]; ii++)
                    for(jj=0; jj<naxes[1]; jj++)
                        data.image[ID_carray1].array.F[jj*naxes[0]+ii] = 0.0;
            }

			usleep(SIMTDELAY);

			clock_gettime(CLOCK_REALTIME, &tnow);
			tnowdouble = 1.0*tnow.tv_sec + 1.0e-9*tnow.tv_nsec;
			tnowdouble *= ATMWF_REALTIMEFACTOR;
            for(layer=NBLAYERS-1; layer!=-1; layer--)
            {
				if(ATMWF_REALTIME==0)
					{
						tnowdouble = (tspan*NBFRAMES+frame)*TIME_STEP;
						printf("\rLayer % 2ld/% 2ld, Frame % 4ld/% 4ld, File % 6ld/% 6ld  [TIME = %10.4f s]  ",layer,NBLAYERS,frame,NBFRAMES,tspan,NB_TSPAN,(tspan*NBFRAMES+frame)*TIME_STEP);
					}
                else
					printf("\rLayer % 2ld/% 2ld, Frame % 4ld/% 4ld, File % 6ld/% 6ld  [PHYSICAL TIME = %.9lf s]  ",layer,NBLAYERS,frame,NBFRAMES,tspan,NB_TSPAN, tnowdouble);
                fflush(stdout);

				// recompute Scoeff for this layer
				Nlambda = AtmosphericTurbulence_stdAtmModel_N(LAYER_ALT[layer], LAMBDA*1000000.0);
				Nslambda = AtmosphericTurbulence_stdAtmModel_N(LAYER_ALT[layer], SLAMBDA*1000000.0);
				Scoeff =  LAMBDA/SLAMBDA * Nslambda/Nlambda; // multiplicative coefficient to go from reference lambda phase to science lambda phase


                if(layer!=NBLAYERS-1)
                {
                    if(super_layer_index[layer+1]!=super_layer_index[layer])
                    {
                        if(FRESNEL_PROPAGATION==1)
                        {
                            // printf("[%g %g %g]",PUPIL_SCALE/pfactor,SLAYER_ALT[super_layer_index[layer+1]]-SLAYER_ALT[super_layer_index[layer]],LAMBDA);
                            Fresnel_propagate_wavefront("array2","array2p",PUPIL_SCALE/pfactor,(SLAYER_ALT[super_layer_index[layer+1]]-SLAYER_ALT[super_layer_index[layer]])/cos(Zangle),LAMBDA);
                            delete_image_ID("array2");
                            chname_image_ID("array2p","array2");
                        }
                        ID_array2 = image_ID("array2");
                        if(make_swavefront==1)
                        {
                            if(FRESNEL_PROPAGATION==1)
                            {
                                Fresnel_propagate_wavefront("sarray2","sarray2p",PUPIL_SCALE/pfactor,(SLAYER_ALT[super_layer_index[layer+1]]-SLAYER_ALT[super_layer_index[layer]])/cos(Zangle),SLAMBDA);
                                delete_image_ID("sarray2");
                                chname_image_ID("sarray2p","sarray2");
                            }
                            ID_sarray2 = image_ID("sarray2");
                        }
                    }
                }

                layer_scale = (SODIUM_ALT-LAYER_ALT[layer])/SODIUM_ALT;

                vpix = 0.0; //0.1*sin(11.0*vindex*(layer+3))*sqrt(vxpix[layer]*vxpix[layer]+vypix[layer]*vypix[layer]);
                PA = sin(10.0*vindex*(layer+2));

				if(ATMWF_REALTIME==1) // real time
				{
					xpos[layer] = xpos0[layer] + vxpix[layer]*tnowdouble + 1.0*xposfcnt[layer]*naxes_MASTER[0];
					ypos[layer] = ypos0[layer] + vypix[layer]*tnowdouble + 1.0*yposfcnt[layer]*naxes_MASTER[0];
				}
				else
				{
					xpos[layer] += vxpix[layer]*TIME_STEP;// + vpix*cos(PA);
					ypos[layer] += vypix[layer]*TIME_STEP;// + vpix*sin(PA);
				}
				
                xref = (long) (xpos[layer]);
                yref = (long) (ypos[layer]);

                while(xpos[layer]<0)
                {
                    xpos[layer] += 1.0*naxes_MASTER[0];
					xposfcnt[layer]++;
                    xref = (long) (xpos[layer]);
                }
                while(xpos[layer]>1.0*naxes_MASTER[0])
                {
                    xpos[layer] -= 1.0*naxes_MASTER[0];
					xposfcnt[layer]--;
                    xref = (long) (xpos[layer]);
                }

                while(ypos[layer]<0)
                {
                    ypos[layer] += 1.0*naxes_MASTER[1];
 					yposfcnt[layer]++;
                    yref = (long) (ypos[layer]);
                }
                while(ypos[layer]>1.0*naxes_MASTER[1])
                {
                    ypos[layer] -= 1.0*naxes_MASTER[1];
                    yposfcnt[layer]--;
                    yref = (long) (ypos[layer]);
                }


                if(xref==naxes_MASTER[0])
                    xref = 0;
                if(yref==naxes_MASTER[1])
                    yref = 0;
                iimax = naxes_MASTER[0]-xref;
                jjmax = naxes_MASTER[1]-yref;
                if(iimax>naxes[0])
                    iimax = naxes[0];
                if(jjmax>naxes[1])
                    jjmax = naxes[1];
                xrefm = xref-naxes_MASTER[0];
                yrefm = yref-naxes_MASTER[1];

                /* make wavefront */

                for(ii=0; ii<naxes[0]; ii++)
                    for(jj=0; jj<naxes[1]; jj++)
                    {
                        iimf = fmod((xpos[layer]+ii),1.0*naxes_MASTER[0]);
                        jjmf = fmod((ypos[layer]+jj),1.0*naxes_MASTER[1]);
                        iim = (long) (iimf);
                        jjm = (long) (jjmf);
                        iifrac = iimf-iim;
                        jjfrac = jjmf-jjm;
                        iim1 = iim+1;
                        jjm1 = jjm+1;
                        if(iim==MASTER_SIZE)
                            iim = 0;
                        if(jjm==MASTER_SIZE)
                            jjm = 0;
                        if(iim1>MASTER_SIZE-1)
                            iim1 -= MASTER_SIZE;
                        if(jjm1>MASTER_SIZE-1)
                            jjm1 -= MASTER_SIZE;

                        //	value = data.image[ID_TML[layer]].array.F[jjm*naxes_MASTER[0]+iim];

                        value = (1.0-iifrac)*(1.0-jjfrac)*data.image[ID_TML[layer]].array.F[jjm*naxes_MASTER[0]+iim];
                        value += (1.0-iifrac)*(jjfrac)*data.image[ID_TML[layer]].array.F[jjm1*naxes_MASTER[0]+iim];
                        value += (iifrac)*(jjfrac)*data.image[ID_TML[layer]].array.F[jjm1*naxes_MASTER[0]+iim1];
                        value += (iifrac)*(1.0-jjfrac)*data.image[ID_TML[layer]].array.F[jjm*naxes_MASTER[0]+iim1];

                        data.image[ID_array1].array.F[jj*naxes[0]+ii] += value;
                        if(WAVEFRONT_AMPLITUDE==1)
                        {
                            re = data.image[ID_array2].array.CF[jj*naxes[0]+ii].re;
                            im = data.image[ID_array2].array.CF[jj*naxes[0]+ii].im;
                            data.image[ID_array2].array.CF[jj*naxes[0]+ii].re = re*cos(value)-im*sin(value);
                            data.image[ID_array2].array.CF[jj*naxes[0]+ii].im = re*sin(value)+im*cos(value);
                        }
                    }



                /* make swavefront */
                if(make_swavefront==1)
                {
                    for(ii=0; ii<naxes[0]; ii++)
                        for(jj=0; jj<naxes[1]; jj++)
                        {
                            iimf = fmod((xpos[layer]+ii),1.0*naxes_MASTER[0]);
                            jjmf = fmod((ypos[layer]+jj),1.0*naxes_MASTER[1]);
                            iim = (long) (iimf);
                            jjm = (long) (jjmf);
                            iifrac = iimf-iim;
                            jjfrac = jjmf-jjm;
                            iim1 = iim+1;
                            jjm1 = jjm+1;
                            if(iim==MASTER_SIZE)
                                iim = 0;
                            if(jjm==MASTER_SIZE)
                                jjm = 0;
                            if(iim1>MASTER_SIZE-1)
                                iim1 -= MASTER_SIZE;
                            if(jjm1>MASTER_SIZE-1)
                                jjm1 -= MASTER_SIZE;

                            value = (1.0-iifrac)*(1.0-jjfrac)*data.image[ID_TML[layer]].array.F[jjm*naxes_MASTER[0]+iim];
                            value += (1.0-iifrac)*(jjfrac)*data.image[ID_TML[layer]].array.F[jjm1*naxes_MASTER[0]+iim];
                            value += (iifrac)*(jjfrac)*data.image[ID_TML[layer]].array.F[jjm1*naxes_MASTER[0]+iim1];
                            value += (iifrac)*(1.0-jjfrac)*data.image[ID_TML[layer]].array.F[jjm*naxes_MASTER[0]+iim1];

                            value *= Scoeff;  // multiplicative coeff to go from ref lambda to science lambda

                            data.image[ID_sarray1].array.F[jj*naxes[0]+ii] += value;

                            if(WAVEFRONT_AMPLITUDE==1)
                            {
                                re = data.image[ID_sarray2].array.CF[jj*naxes[0]+ii].re;
                                im = data.image[ID_sarray2].array.CF[jj*naxes[0]+ii].im;
                                data.image[ID_sarray2].array.CF[jj*naxes[0]+ii].re = re*cos(value)-im*sin(value);
                                data.image[ID_sarray2].array.CF[jj*naxes[0]+ii].im = re*sin(value)+im*cos(value);
                            }
                        }
                }


                /* cwavefront */
                if(make_cwavefront==1)
                {
                    for(ii=0; ii<naxes[0]; ii++)
                        for(jj=0; jj<naxes[1]; jj++)
                        {
                            iim=(long) (fmod((xpos[layer]+naxes[0]/2+(ii-naxes[0]/2)*layer_scale),1.0*naxes_MASTER[0]));
                            jjm=(long) (fmod((ypos[layer]+naxes[1]/2+(jj-naxes[1]/2)*layer_scale),1.0*naxes_MASTER[1]));
                            iim = (long) (iimf);
                            jjm = (long) (jjmf);
                            iifrac = iimf-iim;
                            jjfrac = jjmf-jjm;
                            iim1 = iim+1;
                            jjm1 = jjm+1;
                            if(iim==MASTER_SIZE)
                                iim = 0;
                            if(jjm==MASTER_SIZE)
                                jjm = 0;
                            if(iim1>MASTER_SIZE-1)
                                iim1 -= MASTER_SIZE;
                            if(jjm1>MASTER_SIZE-1)
                                jjm1 -= MASTER_SIZE;

                            value = (1.0-iifrac)*(1.0-jjfrac)*data.image[ID_TML[layer]].array.F[jjm*naxes_MASTER[0]+iim];
                            value += (1.0-iifrac)*(jjfrac)*data.image[ID_TML[layer]].array.F[jjm1*naxes_MASTER[0]+iim];
                            value += (iifrac)*(jjfrac)*data.image[ID_TML[layer]].array.F[jjm1*naxes_MASTER[0]+iim1];
                            value += (iifrac)*(1.0-jjfrac)*data.image[ID_TML[layer]].array.F[jjm*naxes_MASTER[0]+iim1];

                            value *= Scoeff;

                            data.image[ID_carray1].array.F[jj*naxes[0]+ii] += value;

                            if(WAVEFRONT_AMPLITUDE==1)
                            {
                                re = data.image[ID_carray2].array.CF[jj*naxes[0]+ii].re;
                                im = data.image[ID_carray2].array.CF[jj*naxes[0]+ii].im;
                                data.image[ID_carray2].array.CF[jj*naxes[0]+ii].re = re*cos(value)-im*sin(value);
                                data.image[ID_carray2].array.CF[jj*naxes[0]+ii].im = re*sin(value)+im*cos(value);
                            }
                        }
                }
            }



            // REFERENCE LAMBDA
            for(ii=0; ii<naxesout[0]; ii++)
                for(jj=0; jj<naxesout[1]; jj++)
                {
                    ii1 = ii+(naxes[0]-naxesout[0])/2;
                    jj1 = jj+(naxes[1]-naxesout[1])/2;
                    data.image[IDout_array_pha].array.F[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii] = data.image[ID_array1].array.F[jj1*naxes[0]+ii1];
                }

            if(WAVEFRONT_AMPLITUDE==1)
            {
                for(ii=0; ii<naxesout[0]; ii++)
                    for(jj=0; jj<naxesout[1]; jj++)
                    {
                        ii1 = ii+(naxes[0]-naxesout[0])/2;
                        jj1 = jj+(naxes[1]-naxesout[1])/2;
                        array[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii].re = data.image[ID_array2].array.CF[jj1*naxes[0]+ii1].re;
                        array[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii].im = data.image[ID_array2].array.CF[jj1*naxes[0]+ii1].im;

                        re = array[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii].re;
                        im = array[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii].im;
                        data.image[IDout_array_amp].array.F[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii] = sqrt(re*re+im*im);
                        pha = atan2(im,re);
                        data.image[IDout_array_pha].array.F[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii] = pha + 2.0*M_PI*((long) (data.image[IDout_array_pha].array.F[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii]/2.0/M_PI+1000.5) - 1000.0);
                    }
            }




            // WRITE CURRENT WF TO SHARED MEMORY

            if(SHM_OUTPUT == 1)
            {
                if(WAVEFRONT_AMPLITUDE==0)
                {
					for(ii=0; ii<naxesout[0]*naxesout[1]; ii++)
                        data.image[IDshmpha].array.F[ii] = data.image[ID_array1].array.F[frame*naxesout[0]*naxesout[1]+ii];
                }
                else
                {
                    for(ii=0; ii<naxesout[0]*naxesout[1]; ii++)
                    {
                        data.image[IDshmpha].array.F[ii] = data.image[IDout_array_pha].array.F[frame*naxesout[0]*naxesout[1]+ii];
                        data.image[IDshmamp].array.F[ii] = data.image[IDout_array_amp].array.F[frame*naxesout[0]*naxesout[1]+ii];
                    }
                }
            }









            // SCIENCE LAMBDA
            if(make_swavefront==1)
            {
                for(ii=0; ii<naxesout[0]; ii++)
                    for(jj=0; jj<naxesout[1]; jj++)
                    {
                        ii1 = ii+(naxes[0]-naxesout[0])/2;
                        jj1 = jj+(naxes[1]-naxesout[1])/2;
                        data.image[IDout_sarray_pha].array.F[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii] = data.image[ID_sarray1].array.F[jj1*naxes[0]+ii1];
                    }
                if(WAVEFRONT_AMPLITUDE==1)
                {
                    for(ii=0; ii<naxesout[0]; ii++)
                        for(jj=0; jj<naxesout[1]; jj++)
                        {
                            ii1 = ii+(naxes[0]-naxesout[0])/2;
                            jj1 = jj+(naxes[1]-naxesout[1])/2;
                            sarray[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii].re = data.image[ID_sarray2].array.CF[jj1*naxes[0]+ii1].re;
                            sarray[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii].im = data.image[ID_sarray2].array.CF[jj1*naxes[0]+ii1].im;
                            re = sarray[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii].re;
                            im = sarray[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii].im;
                            data.image[IDout_sarray_amp].array.F[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii] = sqrt(re*re+im*im);
                            pha = atan2(im,re);
                            data.image[IDout_sarray_pha].array.F[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii] = pha + 2.0*M_PI*((long) ((data.image[IDout_sarray_pha].array.F[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii]-pha)/2.0/M_PI+1000.5) - 1000.0);
                        }
                }
            }






            if(make_cwavefront==1)
            {
                for(ii=0; ii<naxesout[0]; ii++)
                    for(jj=0; jj<naxesout[1]; jj++)
                    {
                        ii1 = ii+(naxes[0]-naxesout[0])/2;
                        jj1 = jj+(naxes[1]-naxesout[1])/2;
                        carray[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii].re = data.image[ID_carray2].array.CF[jj1*naxes[0]+ii1].re;
                        carray[frame*naxesout[0]*naxesout[1]+jj*naxesout[0]+ii].im = data.image[ID_carray2].array.CF[jj1*naxes[0]+ii1].im;
                    }
            }




            // WRITE CURRENT WF TO SHARED MEMORY
            if((SHM_SOUTPUT == 1)&&(make_swavefront==1))
            {
				switch (SHM_SOUTPUTM) {
					case 1 :					
					coeff = SLAMBDA/2.0/M_PI;
					break;
					case 2 :
					coeff = SLAMBDA/2.0/M_PI*1e6;
					break;
					default :
					coeff = 1.0;
					break;
				}
			
				
      
				if(WAVEFRONT_AMPLITUDE==0)
                {
                    data.image[IDshmspha].md[0].write = 1;
                    data.image[IDshmspha].kw[0].value.numf = tnowdouble;
                    for(ii=0; ii<naxesout[0]*naxesout[1]; ii++)
                        data.image[IDshmspha].array.F[ii] = data.image[ID_sarray1].array.F[frame*naxesout[0]*naxesout[1]+ii]*coeff;
                    data.image[IDshmspha].md[0].cnt0++;
                    data.image[IDshmspha].md[0].write = 0;
                }
                else
                {
                    data.image[IDshmspha].md[0].write = 1;
                    data.image[IDshmsamp].md[0].write = 1;
                    data.image[IDshmspha].kw[0].value.numf = tnowdouble;
                    data.image[IDshmsamp].kw[0].value.numf = tnowdouble;
                    for(ii=0; ii<naxesout[0]*naxesout[1]; ii++)
                    {
                        data.image[IDshmspha].array.F[ii] = data.image[IDout_sarray_pha].array.F[frame*naxesout[0]*naxesout[1]+ii]*coeff;
                        data.image[IDshmsamp].array.F[ii] = data.image[IDout_sarray_amp].array.F[frame*naxesout[0]*naxesout[1]+ii];
                    }
                    data.image[IDshmspha].md[0].cnt0++;
                    data.image[IDshmsamp].md[0].cnt0++;
                    data.image[IDshmspha].md[0].write = 0;
                    data.image[IDshmsamp].md[0].write = 0;
                }

            }
        }




        if(WFOUTPUT==1) // WRITE REFERENCE LAMBDA
        {
            sprintf(fname1,"!%s%08ld.pha",WF_FILE_PREFIX,tspan);
            sprintf(fname2,"!%s%08ld.amp",WF_FILE_PREFIX,tspan);

            save_fl_fits("outarraypha",fname1);


            if(WAVEFRONT_AMPLITUDE==1)
                save_fl_fits("outarrayamp",fname2);
        }
        else if (WFOUTPUT==0)
        {
            // CREATE EMPTY FILES
            sprintf(fname1,"%s%08ld.pha",WF_FILE_PREFIX,tspan);
            sprintf(fname2,"%s%08ld.amp",WF_FILE_PREFIX,tspan);
            sprintf(command,"touch %s",fname1);
            r = system(command);
            if(WAVEFRONT_AMPLITUDE==1)
            {
                sprintf(command,"touch %s",fname2);
                r = system(command);
            }
        }


        if((make_swavefront==1)&&(SWF_WRITE2DISK==1)) // WRITE SCIENCE LAMBDA
        {
            printf("WRITING SCIENCE WAVEFRONT ...");
            fflush(stdout);
            sprintf(fname1,"!%s%08ld.pha",SWF_FILE_PREFIX,tspan);
            sprintf(fname2,"!%s%08ld.amp",SWF_FILE_PREFIX,tspan);


            save_fl_fits("outsarraypha",fname1);

            printf(" - ");
            fflush(stdout);

            if(WAVEFRONT_AMPLITUDE==1)
                save_fl_fits("outsarrayamp",fname2);

            printf("\n");
            fflush(stdout);
        }

    }

    delete_image_ID("array1");
    free(array);
    if(make_swavefront==1)
    {
        delete_image_ID("sarray1");
        free(sarray);
    }
    if(make_cwavefront==1)
    {
        delete_image_ID("carray1");
        free(carray);
    }

    free(SLAYER_ALT);
    free(super_layer_index);
    free(xpos);
    free(ypos);
     free(xpos0);
    free(ypos0);
    free(xposfcnt);
    free(yposfcnt);
   free(vxpix);
    free(vypix);


    free(LAYER_ALT);
    free(LAYER_CN2);
    free(LAYER_SPD);
    free(LAYER_DIR);
    free(LAYER_OUTERSCALE);
    free(LAYER_INNERSCALE);
    free(ID_TM);
    free(ID_TML);

    free(naxes);
    free(naxesout);

    return(0);
}


















int contract_wavefront_series(char *in_prefix, char *out_prefix, long NB_files)
{
  /* contracts the wavefront series by a factor of 2 */
  char fname[200];
  long IDamp,IDpha,IDoutamp,IDoutpha;
  long ii,jj,kk;
  long i,j;
  long naxes[3];
  long naxes_out[3];
  float re,im,amp,pha;
  long index;
  float P;
  long LARGE = 10000;
  float pharef,ampref;

  for(index=0;index<NB_files;index++)
    {
      printf("INDEX = %ld/%ld\n",index,NB_files);
      sprintf(fname,"%s%08ld.pha",in_prefix,index);
      load_fits(fname,"tmpwfp");
      IDpha=image_ID("tmpwfp");
      sprintf(fname,"%s%08ld.amp",in_prefix,index);
      load_fits(fname,"tmpwfa");
      IDamp=image_ID("tmpwfa");
      naxes[0] = data.image[IDpha].md[0].size[0];
      naxes[1] = data.image[IDpha].md[0].size[1];
      naxes[2] = data.image[IDpha].md[0].size[2];
      naxes_out[0] = data.image[IDpha].md[0].size[0]/2;
      naxes_out[1] = data.image[IDpha].md[0].size[1]/2;
      naxes_out[2] = data.image[IDpha].md[0].size[2];
      IDoutpha = create_3Dimage_ID("tmpwfop",naxes_out[0],naxes_out[1],naxes_out[2]);
      IDoutamp = create_3Dimage_ID("tmpwfoa",naxes_out[0],naxes_out[1],naxes_out[2]);
      
      ii=0;
      jj=0;
      kk=0;
      amp = 0.0;
      pha = 0.0;
      for(kk=0;kk<naxes[2];kk++)
	{
	  for(ii=0;ii<naxes[0]/2;ii++)
	    for(jj=0;jj<naxes[1]/2;jj++)
	      {
		re=0.0;
		im=0.0;
		pharef = 0.0;
		ampref = 0.0;
		for(i=0;i<2;i++)
		  for(j=0;j<2;j++)
		    {
		      amp = data.image[IDamp].array.F[kk*naxes[0]*naxes[1]+(2*jj+j)*naxes[0]+2*ii+i];
		      pha = data.image[IDpha].array.F[kk*naxes[0]*naxes[1]+(2*jj+j)*naxes[0]+2*ii+i];
		      pharef += data.image[IDamp].array.F[kk*naxes[0]*naxes[1]+(2*jj+j)*naxes[0]+2*ii+i]*data.image[IDpha].array.F[kk*naxes[0]*naxes[1]+(2*jj+j)*naxes[0]+2*ii+i];
		      ampref += data.image[IDamp].array.F[kk*naxes[0]*naxes[1]+(2*jj+j)*naxes[0]+2*ii+i];
		      re += amp*cos(pha);
		      im += amp*sin(pha);
		    }
		amp = sqrt(re*re+im*im);
		pha = atan2(im,re);
		pharef /= ampref;
		P = 2.0*PI*( ((long) (0.5+1.0*LARGE+(pharef-pha)/2.0/PI)) - LARGE);
		if(ampref<0.01)
		  P = 0.0;
		data.image[IDoutpha].array.F[kk*naxes_out[0]*naxes_out[1]+jj*naxes_out[0]+ii] = pha+P;
		data.image[IDoutamp].array.F[kk*naxes_out[0]*naxes_out[1]+jj*naxes_out[0]+ii] = amp/4.0;
	      }
	}
      sprintf(fname,"%s%8ld.pha",out_prefix,index);
      replace_char(fname,' ','0');
      save_fl_fits("tmpwfop",fname);
      sprintf(fname,"%s%8ld.amp",out_prefix,index);
      replace_char(fname,' ','0');
      save_fl_fits("tmpwfoa",fname);

      delete_image_ID("tmpwfa");
      delete_image_ID("tmpwfp");
      delete_image_ID("tmpwfoa");
      delete_image_ID("tmpwfop");
    }

  return(0);
}


//
// analyze WF series: PSF FWHM and aperture photometry
//

int measure_wavefront_series(float factor)
{
  char KEYWORD[200];
  char CONTENT[200];
  float TIME_STEP;
  float TIME_SPAN;
  long NB_TSPAN;
  char WF_FILE_PREFIX[100];
  float PUPIL_SCALE;
  float FOCAL_SCALE;
  float LAMBDA;
  long WFsize;
  double tmp;
  long ID,IDpsf,IDamp,IDpha;
  long IDpupamp;
  long tspan;

  long ID_array1;
  float amp,pha;

  char fnameamp[200];
  char fnamepha[200];

  long naxes[3];
  long frame;
  long NBFRAMES;
  long ii,jj;
  int amplitude_on;

  double puprad = 0.035; // meter
  double pupradpix;
  double psfflux;
  double psfflux1; // within 1 arcsec radius
  double psfflux2; // within 2 arcsec radius
  double psfflux5; // within 5 arcsec radius 
  double psfflux10; // within 10 arcsec radius
  double psfflux20; // within 20 arcsec radius
  
  double dx, dy, r;
  FILE *fpphot;

  strcpy(KEYWORD,"PUPIL_SCALE");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  PUPIL_SCALE = atof(CONTENT);
  pupradpix = puprad/PUPIL_SCALE;
  printf("pupradpix = %f m\n",pupradpix);

  strcpy(KEYWORD,"SLAMBDA");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  LAMBDA = 0.000001*atof(CONTENT);

  strcpy(KEYWORD,"WFsize");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  WFsize = atol(CONTENT);
 

  FOCAL_SCALE = LAMBDA/WFsize/PUPIL_SCALE/PI*180.0*3600.0; /* in arcsecond per pixel */
  printf("Scale is %f arcsecond per pixel (%ld pixels)\n",FOCAL_SCALE,WFsize);

  strcpy(KEYWORD,"PUPIL_AMPL_FILE");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  if(image_ID("ST_pa")==-1)
    {
      load_fits(CONTENT,"ST_pa");
    }

  IDpupamp = image_ID("ST_pa");
  naxes[0]=data.image[ID].md[0].size[0];
  naxes[1]=data.image[ID].md[0].size[1];

  strcpy(KEYWORD,"WFTIME_STEP");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  TIME_STEP = atof(CONTENT);
  strcpy(KEYWORD,"TIME_SPAN");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  TIME_SPAN = atof(CONTENT);
  strcpy(KEYWORD,"NB_TSPAN");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  NB_TSPAN = atol(CONTENT);
  strcpy(KEYWORD,"SWF_FILE_PREFIX");
  read_config_parameter(CONFFILE,KEYWORD,WF_FILE_PREFIX);
  strcpy(KEYWORD,"WAVEFRONT_AMPLITUDE");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  amplitude_on = atoi(CONTENT);

  strcpy(KEYWORD,"PUPIL_AMPL_FILE");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  IDamp = load_fits(CONTENT,"pupil");

  NBFRAMES = (long) (TIME_SPAN/TIME_STEP);
  naxes[2]=NBFRAMES;

  ID_array1 = create_2DCimage_ID("array1", naxes[0], naxes[1]);

  IDpsf = create_2Dimage_ID("PSF", naxes[0], naxes[1]);

  fpphot = fopen("phot.txt","w");
  fclose(fpphot);

  for(tspan=0;tspan<NB_TSPAN;tspan++)
    {
      printf("%ld/%ld\n",tspan,NB_TSPAN);
      sprintf(fnamepha,"%s%8ld.pha",WF_FILE_PREFIX,tspan);
      replace_char(fnamepha,' ','0');
      sprintf(fnameamp,"%s%8ld.amp",WF_FILE_PREFIX,tspan);
      replace_char(fnameamp,' ','0');
      IDpha = load_fits(fnamepha,"wfpha");
      if(amplitude_on==1)
	IDamp = load_fits(fnameamp,"wfamp");

      for(frame=0;frame<NBFRAMES;frame++)
	{
	  psfflux = 0.0;
	  psfflux1 = 0.0;
	  psfflux2 = 0.0;
	  psfflux5 = 0.0;
	  psfflux10 = 0.0;
	  psfflux20 = 0.0;
	  if(amplitude_on==1)
	    for(ii=0;ii<naxes[0];ii++)
	      for(jj=0;jj<naxes[1];jj++)
		{
		  amp = data.image[IDamp].array.F[frame*naxes[0]*naxes[1]+jj*naxes[0]+ii]*data.image[IDpupamp].array.F[jj*naxes[0]+ii];
		  pha = factor*data.image[IDpha].array.F[frame*naxes[0]*naxes[1]+jj*naxes[0]+ii];
		  data.image[ID_array1].array.CF[jj*naxes[0]+ii].re = amp*cos(pha);
		  data.image[ID_array1].array.CF[jj*naxes[0]+ii].im = amp*sin(pha);
		  psfflux += amp*amp;
		}
	  else
	    for(ii=0;ii<naxes[0];ii++)
	      for(jj=0;jj<naxes[1];jj++)
		{
		  amp = data.image[IDpupamp].array.F[jj*naxes[0]+ii];
		  pha = factor*data.image[IDpha].array.F[frame*naxes[0]*naxes[1]+jj*naxes[0]+ii];
		  data.image[ID_array1].array.CF[jj*naxes[0]+ii].re = amp*cos(pha);
		  data.image[ID_array1].array.CF[jj*naxes[0]+ii].im = amp*sin(pha);
		}

	  do2dfft("array1","im_c");
	  permut("im_c");
	  ID=image_ID("im_c");
	  for(ii=0;ii<naxes[0];ii++)
	    for(jj=0;jj<naxes[1];jj++)
	      {
		dx = 1.0*ii-naxes[0]/2;
		dy = 1.0*jj-naxes[1]/2;
		r = sqrt(dx*dx+dy*dy);
		tmp = (data.image[ID].array.CF[jj*naxes[0]+ii].re*data.image[ID].array.CF[jj*naxes[0]+ii].re+data.image[ID].array.CF[jj*naxes[0]+ii].im*data.image[ID].array.CF[jj*naxes[0]+ii].im);
		data.image[IDpsf].array.F[jj*naxes[0]+ii] += tmp;
		if(r<1.0/FOCAL_SCALE)
		  psfflux1 += tmp;
		if(r<2.0/FOCAL_SCALE)
		  psfflux2 += tmp;
		if(r<5.0/FOCAL_SCALE)
		  psfflux5 += tmp;
		if(r<10.0/FOCAL_SCALE)
		  psfflux10 += tmp;
		if(r<20.0/FOCAL_SCALE)
		  psfflux20 += tmp;		
	      }
	  delete_image_ID("im_c");
	  printf("%.6f %.4f %.4f %.4f %.4f %.4f %.4f\n", (tspan*NBFRAMES+frame)*TIME_STEP, psfflux, psfflux1, psfflux2, psfflux5, psfflux10, psfflux20);
	  fpphot = fopen("phot.txt","a");
	  fprintf(fpphot,"%.6f %.4f %.4f %.4f %.4f %.4f %.4f\n", (tspan*NBFRAMES+frame)*TIME_STEP, psfflux, psfflux1, psfflux2, psfflux5, psfflux10, psfflux20);
	  fclose(fpphot);
	}    
      
      delete_image_ID("wfamp");
      delete_image_ID("wfpha");
    }
  delete_image_ID("array1");
  save_fl_fits("PSF","!PSF.fits");
  tmp = measure_FWHM("PSF",1.0*naxes[0]/2,1.0*naxes[1]/2,1.0,naxes[0]/2);
  printf("FWHM = %f arcseconds (%f pixels)\n",FOCAL_SCALE*tmp,tmp);

  return(0);
}





int measure_wavefront_series_expoframes(float etime, char *outfile)
{
  char KEYWORD[200];
  char CONTENT[200];
  float TIME_STEP;
  float TIME_SPAN;
  long NB_TSPAN;
  char WF_FILE_PREFIX[100];
  float PUPIL_SCALE;
  float FOCAL_SCALE;
  float LAMBDA;
  long WFsize;
  float tmp,tmp1;
  long ID,IDpsf,IDamp,IDpha;
  long tspan;
  FILE *fp;
  char command[200];
  float frac = 0.5;

  long ID_array1;
  float amp,pha;

  char fnameamp[200];
  char fnamepha[200];
  char fname[200];
  
  long naxes[3];
  long frame;
  long NBFRAMES;
  long ii,jj;
  float etime_left;
  long frame_number;
  double *xcenter;
  double *ycenter;
  long amplitude_on;

  xcenter = (double*) malloc(sizeof(double));
  ycenter = (double*) malloc(sizeof(double));

  printf("Frame exposure time is %f s\n",etime);

  strcpy(KEYWORD,"PUPIL_SCALE");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  PUPIL_SCALE = atof(CONTENT);
  strcpy(KEYWORD,"LAMBDA");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  LAMBDA = 0.000001*atof(CONTENT);

  strcpy(KEYWORD,"WFsize");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  WFsize = atol(CONTENT);
 

  FOCAL_SCALE = LAMBDA/WFsize/PUPIL_SCALE/PI*180.0*3600.0; /* in arcsecond per pixel */
  printf("Scale is %f arcsecond per pixel (%ld pixels)\n",FOCAL_SCALE,WFsize);

  strcpy(KEYWORD,"PUPIL_AMPL_FILE");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  if(image_ID("ST_pa")==-1)
    {
      load_fits(CONTENT,"ST_pa");
    }

  ID=image_ID("ST_pa");
  naxes[0]=data.image[ID].md[0].size[0];
  naxes[1]=data.image[ID].md[0].size[1];

  strcpy(KEYWORD,"WFTIME_STEP");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  TIME_STEP = atof(CONTENT);
  printf("time step is %f s\n",TIME_STEP);
  strcpy(KEYWORD,"TIME_SPAN");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  TIME_SPAN = atof(CONTENT);
  strcpy(KEYWORD,"NB_TSPAN");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  NB_TSPAN = atol(CONTENT);
  strcpy(KEYWORD,"WF_FILE_PREFIX");
  read_config_parameter(CONFFILE,KEYWORD,WF_FILE_PREFIX);

  strcpy(KEYWORD,"WAVEFRONT_AMPLITUDE");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  amplitude_on = atoi(CONTENT);

  strcpy(KEYWORD,"PUPIL_AMPL_FILE");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  IDamp = load_fits(CONTENT,"pupil");

  NBFRAMES = (long) (TIME_SPAN/TIME_STEP);
  naxes[2]=NBFRAMES;

  ID_array1 = create_2DCimage_ID("array1", naxes[0], naxes[1]);

  IDpsf = create_2Dimage_ID("PSF",naxes[0],naxes[1]);
  frame_number = 0;
  etime_left = etime;

  sprintf(command,"rm -rf %s",outfile);
  if(system(command)==-1)
    {
      printf("ERROR: system(\"%s\"), %s line %d\n",command,__FILE__,__LINE__);
      exit(0);
    }
  
  if((fp=fopen(outfile,"w"))==NULL)
    {
      printf("Cannot create file %s\n",outfile);
      exit(0);
    }
  fclose(fp);


  for(tspan=0;tspan<NB_TSPAN;tspan++)
    {
      printf("%ld/%ld\n",tspan,NB_TSPAN);
      sprintf(fnamepha,"%s%8ld.pha",WF_FILE_PREFIX,tspan);
      replace_char(fnamepha,' ','0');
      sprintf(fnameamp,"%s%8ld.amp",WF_FILE_PREFIX,tspan);
      replace_char(fnameamp,' ','0');
      IDpha = load_fits(fnamepha,"wfpha");
      if(amplitude_on==1)
	{
	  printf("reading amp\n");
	  fflush(stdout);
	  IDamp = load_fits(fnameamp,"wfamp");
	}

      for(frame=0;frame<NBFRAMES;frame++)
	{
	  if(amplitude_on==1)
	    for(ii=0;ii<naxes[0];ii++)
	      for(jj=0;jj<naxes[1];jj++)
		{
		  amp = data.image[IDamp].array.F[frame*naxes[0]*naxes[1]+jj*naxes[0]+ii];
		  pha = data.image[IDpha].array.F[frame*naxes[0]*naxes[1]+jj*naxes[0]+ii];
		  data.image[ID_array1].array.CF[jj*naxes[0]+ii].re = amp*cos(pha);
		  data.image[ID_array1].array.CF[jj*naxes[0]+ii].im = amp*sin(pha);
		}
	  else
	    for(ii=0;ii<naxes[0];ii++)
	      for(jj=0;jj<naxes[1];jj++)
		{
		  amp = data.image[IDamp].array.F[jj*naxes[0]+ii];
		  pha = data.image[IDpha].array.F[frame*naxes[0]*naxes[1]+jj*naxes[0]+ii];
		  data.image[ID_array1].array.CF[jj*naxes[0]+ii].re = amp*cos(pha);
		  data.image[ID_array1].array.CF[jj*naxes[0]+ii].im = amp*sin(pha);
		}
	  
      do2dfft("array1","im_c");
      permut("im_c");
      ID=image_ID("im_c");
      for(ii=0;ii<naxes[0];ii++)
	for(jj=0;jj<naxes[1];jj++)
	  {
	    data.image[IDpsf].array.F[jj*naxes[0]+ii] += (data.image[ID].array.CF[jj*naxes[0]+ii].re*data.image[ID].array.CF[jj*naxes[0]+ii].re+data.image[ID].array.CF[jj*naxes[0]+ii].im*data.image[ID].array.CF[jj*naxes[0]+ii].im);
	  }
      delete_image_ID("im_c");
      
      etime_left -= TIME_STEP;
      if(etime_left<0)
	{
	  sprintf(fname,"!PSF%ld",frame_number);
	  save_fl_fits("PSF",fname);
	  gauss_filter("PSF","PSFg",3,10);
	  center_PSF("PSFg", xcenter, ycenter, naxes[0]/2);
	  tmp = measure_FWHM("PSFg",xcenter[0],ycenter[0],1.0,naxes[0]/2);
	  printf("%ld FWHM %f arcseconds (%f pixels)\n",frame_number,FOCAL_SCALE*tmp,tmp);
	  tmp1 = measure_enc_NRJ("PSF",xcenter[0],ycenter[0],frac);
	  printf("Encircled energy (%f) is %f arcseconds\n",frac,tmp1*FOCAL_SCALE);
	  delete_image_ID("PSFg");
	  if((fp=fopen(outfile,"a"))==NULL)
	    {
	      printf("Cannot open file %s\n",outfile);
	      exit(0);
	    }
	  fprintf(fp,"%ld %f %f %f %f\n",frame_number,FOCAL_SCALE*tmp,2.0*FOCAL_SCALE*tmp1,xcenter[0],ycenter[0]);
	  fclose(fp);
	  
	  arith_image_zero("PSF");
	  etime_left = etime;
	  frame_number++;
	  printf("Working on frame %ld\n",frame_number);
	}

	}
      delete_image_ID("wfamp");
      delete_image_ID("wfpha");
    }
  free(xcenter);
  free(ycenter);
  delete_image_ID("array1");
  save_fl_fits("PSF","!PSF");
  tmp = measure_FWHM("PSF",1.0*naxes[0]/2,1.0*naxes[1]/2,1.0,naxes[0]/2);
  printf("FWHM = %f arcseconds (%f pixels)\n",FOCAL_SCALE*tmp,tmp);

  return(0);
}

int frame_select_PSF(char *logfile, long NBfiles, float frac)
{
  /* logfile has the following format:
     <PSF file name> <FWHM> <Enc.ener.0.5> <centerx> <centery>
  */
  /* outputs the following files :
     PSFc:    coadded PSF (no centering/filtering)
     PSFcc:   coadded PSF with centering
     PSFccsf: coadded PSF with centering and selection on FWHM (frac= fraction of the frames kept)
     PSFccse: coadded PSF with centering and selection on Enc.ener.(frac= fraction of the frames kept)
  */
  FILE *fp;
  int OK;
  long i;
  float *FWHM;
  float *ENCE;
  float *xcen;
  float *ycen;
  char fname[200];
  float Xcenter,Ycenter;
  float Xcenter_c,Ycenter_c;
  float Xcenter_cc,Ycenter_cc;
  float Xcenter_ccsf,Ycenter_ccsf;
  float Xcenter_ccse,Ycenter_ccse;
  float limit;
  long cnt;
  float fwhm1,fwhm2,fwhm3,fwhm4;
  float ence1,ence2,ence3,ence4;
  float fs = 0.01128;

  Xcenter_c = 128;
  Ycenter_c = 128;

  FWHM = (float*) malloc(sizeof(float)*NBfiles);
  ENCE = (float*) malloc(sizeof(float)*NBfiles);
  xcen = (float*) malloc(sizeof(float)*NBfiles);
  ycen = (float*) malloc(sizeof(float)*NBfiles);

  /* make PSFc */
  if((fp=fopen(logfile,"r"))==NULL)
    {
      printf("ERROR: cannot open file \"%s\"\n",logfile);
      exit(0);
    }
  for(i=0;i<NBfiles;i++)
    {
      if(fscanf(fp,"%s %f %f %f %f\n",fname,&FWHM[i],&ENCE[i],&xcen[i],&ycen[i])!=5)
	{
	  printf("ERROR: fscanf, %s line %d\n",__FILE__,__LINE__);
	  exit(0);
	}

      if(i==0)
	load_fits(fname,"PSFc");
      else
	{
	  load_fits(fname,"tmppsf");
	  execute_arith("PSFc=PSFc+tmppsf");
	  delete_image_ID("tmppsf");
	}
    }
  fclose(fp);

  /* make PSFcc */
  Xcenter = 0.0;
  Ycenter = 0.0;
  if((fp=fopen(logfile,"r"))==NULL)
    {
      printf("ERROR: cannot open file \"%s\"\n",logfile);
      exit(0);
    }
  for(i=0;i<NBfiles;i++)
    {
      if(fscanf(fp,"%s %f %f %f %f\n",fname,&FWHM[i],&ENCE[i],&xcen[i],&ycen[i])!=5)
	{
	  printf("ERROR: fscanf, %s line %d\n",__FILE__,__LINE__);
	  exit(0);
	}

      if(i==0)
	{
	  load_fits(fname,"PSFcc");
	  Xcenter = xcen[0];
	  Ycenter = ycen[0];
	}
      else
	{
	  load_fits(fname,"tmppsf");
	  basic_add("PSFcc","tmppsf","nPSFcc",Xcenter-xcen[i],Ycenter-ycen[i]);
	  if(Xcenter<xcen[i])
	    Xcenter = xcen[i];
	  if(Ycenter<ycen[i])
	    Ycenter = ycen[i];
	  delete_image_ID("PSFcc");
	  delete_image_ID("tmppsf");
	  chname_image_ID("nPSFcc","PSFcc");
	}
    }
  fclose(fp);
  Xcenter_cc = Xcenter;
  Ycenter_cc = Ycenter;

  /* make PSFccsf */
  quick_sort_float(FWHM, NBfiles);
  limit = FWHM[(long) (frac*NBfiles)];
  Xcenter = 0.0;
  Ycenter = 0.0;
  if((fp=fopen(logfile,"r"))==NULL)
    {
      printf("ERROR: cannot open file \"%s\"\n",logfile);
      exit(0);
    }
  OK = 0;
  cnt = 0;
  for(i=0;i<NBfiles;i++)
    {
      if(fscanf(fp,"%s %f %f %f %f\n",fname,&FWHM[i],&ENCE[i],&xcen[i],&ycen[i])!=5)
	{
	  printf("ERROR: fscanf, %s line %d\n",__FILE__,__LINE__);
	  exit(0);
	}

      if(FWHM[i]<limit)
	{
	  cnt++;
	  if(OK==0)
	    {
	      load_fits(fname,"PSFccsf");
	      Xcenter = xcen[i];
	      Ycenter = ycen[i];
	      OK=1;
	    }
	  else
	    {
	      load_fits(fname,"tmppsf");
	      basic_add("PSFccsf","tmppsf","nPSFccsf",Xcenter-xcen[i],Ycenter-ycen[i]);
	      if(Xcenter<xcen[i])
		Xcenter = xcen[i];
	      if(Ycenter<ycen[i])
		Ycenter = ycen[i];
	      delete_image_ID("PSFccsf");
	      delete_image_ID("tmppsf");
	      chname_image_ID("nPSFccsf","PSFccsf");
	    }
	}
    }
  fclose(fp);
  printf("PSFccsf: %ld frames kept\n",cnt);
  Xcenter_ccsf = Xcenter;
  Ycenter_ccsf = Ycenter;

  /* make PSFccse */
  quick_sort_float(ENCE, NBfiles);
  limit = ENCE[(long) (frac*NBfiles)];
  Xcenter = 0.0;
  Ycenter = 0.0;
  if((fp=fopen(logfile,"r"))==NULL)
    {
      printf("ERROR: cannot open file \"%s\"\n",logfile);
      exit(0);
    }
  OK = 0;
  cnt = 0;
  for(i=0;i<NBfiles;i++)
    {
      if(fscanf(fp,"%s %f %f %f %f\n",fname,&FWHM[i],&ENCE[i],&xcen[i],&ycen[i])!=5)
	{
	  printf("ERROR: fscanf, %s line %d\n",__FILE__,__LINE__);
	  exit(0);
	}
      if(ENCE[i]<limit)
	{
	  cnt++;
	  if(OK==0)
	    {
	      load_fits(fname,"PSFccse");
	      Xcenter = xcen[i];
	      Ycenter = ycen[i];
	      OK=1;
	    }
	  else
	    {
	      load_fits(fname,"tmppsf");
	      basic_add("PSFccse","tmppsf","nPSFccse",Xcenter-xcen[i],Ycenter-ycen[i]);
	      if(Xcenter<xcen[i])
		Xcenter = xcen[i];
	      if(Ycenter<ycen[i])
		Ycenter = ycen[i];
	      delete_image_ID("PSFccse");
	      delete_image_ID("tmppsf");
	      chname_image_ID("nPSFccse","PSFccse");
	    }
	}
    }
  fclose(fp);
  printf("PSFccse : %ld frames kept\n",cnt);
  Xcenter_ccse = Xcenter;
  Ycenter_ccse = Ycenter;


  /* quality evaluation */
  fwhm1 = measure_FWHM("PSFc",Xcenter_c,Ycenter_c,1.0,128);
  fwhm2 = measure_FWHM("PSFcc",Xcenter_cc,Ycenter_cc,1.0,128);
  fwhm3 = measure_FWHM("PSFccsf",Xcenter_ccsf,Ycenter_ccsf,1.0,128);
  fwhm4 = measure_FWHM("PSFccse",Xcenter_ccse,Ycenter_ccse,1.0,128);
  ence1 = measure_enc_NRJ("PSFc",Xcenter_c,Ycenter_c,0.5);  
  ence2 = measure_enc_NRJ("PSFcc",Xcenter_cc,Ycenter_cc,0.5);  
  ence3 = measure_enc_NRJ("PSFccsf",Xcenter_ccsf,Ycenter_ccsf,0.5);  
  ence4 = measure_enc_NRJ("PSFccse",Xcenter_ccse,Ycenter_ccse,0.5);  

  printf("PSFc   :  %f %f\n",fwhm1*fs,2.0*ence1*fs);
  printf("PSFcc  :  %f %f\n",fwhm2*fs,2.0*ence2*fs);
  printf("PSFccsf:  %f %f\n",fwhm3*fs,2.0*ence3*fs);
  printf("PSFccse:  %f %f\n",fwhm4*fs,2.0*ence4*fs);

  free(FWHM);
  free(ENCE);
  free(xcen);
  free(ycen);

  return(0);
}



// explore long exposure PSF structure
double AtmosphericTurbulence_makePSF(double Kp, double Ki, double Kd, double Kdgain)
{
  FILE *fp;
  char wf_file_name[200];
  double PupScale = 0.01;



  // SIMULATION PARAMETERS

  long WFSLAMBDA = 600; // [nm]
  double zeroptWFS = 8.354e10; // [ph/s/um/m2] (600 nm)
  //double zeroptWFS = 9.444e9; // [ph/s/um/m2] (1600 nm)


  long SCILAMBDA = 1600; // [nm]
  double zeroptSCI = 9.444e9; // [ph/s/um/m2] (H band)
  

  
  double TelDiam = 30.0;
  double etime = 10.0; // end of exposure [s]
  double etimestart = 0.01; // loop closing delay before start of exposure [s]
  double dtime = 0.00001; // internal time step, 0.1 ms
  double WFS_SamplingTime = 0.00025; // WFS sampling time [sec]
  double WFS_Delay = 0.0002; // [sec]  DELAY SHOULD BE SMALLER THAN SAMPLING TIME

  double bandpassWFS = 0.1; // [um]
  double bandpassSCI = 0.1; // [um]
  double throughputWFS = 0.1;
  double throughputSCI = 0.1;
  double magnWFS = 6.0;
  double magnSCI = 6.0;
  double FLUXSCI; // [ph/s]
  double FLUXWFS; // [ph/s]

  double rtime; // running time

  // input parameters
  char KEYWORD[200];
  char CONTENT[200];
  double WFTIME_STEP;
  float TIME_SPAN;
  float PUPIL_SCALE;
  float FOCAL_SCALE;
  float LAMBDA;
  long WFsize;

  long BINWF = 2; // 2 for 30m telescope
  long WFsize1; // after binning by BINWF

  long size = 512;
  long BINFACTOR = 8; // 8 for 8m telescope
  long sizeb;
  
  char WFDIRECTORY[200];
  char fnameamp[200];
  char fnamepha[200];
  char fname[200];
  
  long NBFRAMES;
  long CubeSize;
  long frame0, frame1, frameindex0, frameindex1, cubeindex0, cubeindex1;
  long frame;  
  long ii, jj, ii1, jj1;
  long IDac0, IDac1, IDpc0, IDpc1;
  long IDacs0, IDacs1, IDpcs0, IDpcs1;
  char imname[200];
  double framefrac, framef;
  double amp, pha, val0, val1;
  double wfstime, wfstime1;
  long wfscnt;

  int WFSdelayWait;

  long IDtelpup;
  long IDatm_amp, IDatm_opd;
  long IDatm_amp_sci, IDatm_opd_sci;
  long IDwfs_opd, IDwfs_amp, IDwfs_mes_opd, IDwfs_mes_opd_prev;
  long IDwfs_mes_opd_derivative, IDwfs_mes_opd_integral;
  long IDdm_opd, IDdm_opd_tmp;
  long IDsci_amp, IDsci_opd;
  double tot;

  double RMSwf;

  long IDpupa, IDpupp;
  long ID, IDpsfcumul, ID1, IDpsfcumul1, IDre, IDim;
  double peak, re, im, reave, imave, tot0;
  double re_sci, im_sci, errpha, pha_ave, pha_ave_sci;
  double tmpd;
  long i, j;
  long cnt;

  long IDtmp;


  int PIDok = 0;  
  double value = 0.0; 
  long valuecnt = 0;
 

  
  

  FLUXSCI = zeroptSCI*M_PI*TelDiam*TelDiam/4.0*bandpassSCI*throughputSCI/pow(2.511886,magnSCI);
  printf("FLUX SCI = %g ph/s\n", FLUXSCI);
  FLUXWFS = zeroptWFS*M_PI*TelDiam*TelDiam/4.0*bandpassWFS*throughputWFS/pow(2.511886,magnWFS);
  printf("FLUX WFS = %g ph/s\n", FLUXWFS);

  sprintf(WFDIRECTORY,"/media/data1/WFsim/AtmSim_0.01");
  sprintf(CONFFILE, "%s/WF%04ld/AOsim.conf", WFDIRECTORY, WFSLAMBDA);
  AtmosphericTurbulence_change_configuration_file(CONFFILE);

  printf("Frame exposure time is %f s\n", etime);

  strcpy(KEYWORD,"PUPIL_SCALE");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  PUPIL_SCALE = atof(CONTENT);
  printf("PUPIL SCALE = %f m\n", PUPIL_SCALE);
  printf("PUPIL DIAM = %f pix\n", TelDiam/PUPIL_SCALE);

  strcpy(KEYWORD,"SLAMBDA");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  LAMBDA = 0.000001*atof(CONTENT); // [m]

  strcpy(KEYWORD,"WFsize");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  WFsize = atol(CONTENT);
 
  WFsize1 = WFsize/BINWF;

  FOCAL_SCALE = LAMBDA/WFsize/PUPIL_SCALE/PI*180.0*3600.0/BINWF; /* in arcsecond per pixel */
  printf("Scale is %f arcsecond per pixel (%ld pixels)\n",FOCAL_SCALE,WFsize);

  strcpy(KEYWORD,"WFTIME_STEP");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  WFTIME_STEP = atof(CONTENT);
  printf("time step is %f s\n",WFTIME_STEP);

  strcpy(KEYWORD,"TIME_SPAN");
  read_config_parameter(CONFFILE,KEYWORD,CONTENT);
  TIME_SPAN = atof(CONTENT);

  CubeSize = (long) (TIME_SPAN/WFTIME_STEP-0.001);
  NBFRAMES = (long) (1.0*etime/WFTIME_STEP);

  printf("CUBE SIZE = %ld\n", CubeSize);


  // MAKE PUPIL MASK
  IDtelpup = make_disk("TelPup", WFsize1, WFsize1, WFsize1/2, WFsize1/2, TelDiam*0.5/PUPIL_SCALE/BINWF);


  IDatm_opd = create_2Dimage_ID("atmopd", WFsize1, WFsize1); // Atmosphere OPD at WFS lambda
  IDatm_amp = create_2Dimage_ID("atmamp", WFsize1, WFsize1); // Atmosphere amplitude at WFS lambda

  IDatm_opd_sci = create_2Dimage_ID("atmopdsci", WFsize1, WFsize1); // Atmosphere OPD at SCI lambda
  IDatm_amp_sci = create_2Dimage_ID("atmampsci", WFsize1, WFsize1); // Atmosphere amplitude at SCI lambda

  IDwfs_opd = create_2Dimage_ID("wfsopd", WFsize1, WFsize1); // WFS OPD (corrected by DM)
  IDwfs_amp = create_2Dimage_ID("wfsamp", WFsize1, WFsize1); // WFS amplitude (corrected by DM)

  IDdm_opd_tmp = create_2Dimage_ID("dmopdtmp", WFsize1, WFsize1); // DM opd (before being sent to DM)
  IDdm_opd = create_2Dimage_ID("dmopd", WFsize1, WFsize1); // DM opd

  IDwfs_mes_opd = create_2Dimage_ID("wfsmesopd", WFsize1, WFsize1); // measured WFS OPD 
  IDwfs_mes_opd_prev = create_2Dimage_ID("wfsmesopdprev", WFsize1, WFsize1); // previous measured WFS OPD 
  IDwfs_mes_opd_derivative = create_2Dimage_ID("wfsmesopdder", WFsize1, WFsize1); // derivative of measured WFS OPD 
  IDwfs_mes_opd_integral = create_2Dimage_ID("wfsmesopdint", WFsize1, WFsize1); // integral of measured WFS OPD 

  IDsci_opd = create_2Dimage_ID("sciopd", WFsize1, WFsize1); // SCI OPD (corrected by DM)
  IDsci_amp = create_2Dimage_ID("sciamp", WFsize1, WFsize1); // SCI amplitude (corrected by DM)

  sizeb = size*BINFACTOR;
  IDpupa = create_2Dimage_ID("pupa", sizeb, sizeb);
  IDpupp = create_2Dimage_ID("pupp", sizeb, sizeb);
  IDpsfcumul = create_2Dimage_ID("PSFcumul", size, size);
  IDpsfcumul1 = create_2Dimage_ID("PSFcumul1", size, size);


  frame = 0;
  frame = 0;
  rtime = 0.0;
  framefrac = 0.0;
  framef = 0.0;
  cubeindex0 = 0;
  cubeindex1 = 0;
  frameindex0 = 0;
  frameindex1 = 1;

  /*  sprintf(fnamepha, "%s/WF0800/WF4096/wf_%08ld.pha", WFDIRECTORY, cubeindex1);
  sprintf(fnameamp, "%s/WF0800/WF4096/wf_%08ld.amp", WFDIRECTORY, cubeindex1);
  ID_WFphaC = load_fits(fnamepha, "WFphaC");
  ID_WFampC = load_fits(fnameamp, "WFampC");
  */

  wfstime = 0.0;
  for(ii=0;ii<WFsize1*WFsize1;ii++)
    {
      data.image[IDwfs_opd].array.F[ii] = 0.0;
      data.image[IDdm_opd].array.F[ii] = 0.0;
      data.image[IDwfs_mes_opd].array.F[ii] = 0.0;
      data.image[IDwfs_mes_opd_prev].array.F[ii] = 0.0;
      data.image[IDwfs_mes_opd_derivative].array.F[ii] = 0.0;
      data.image[IDwfs_mes_opd_integral].array.F[ii] = 0.0;
    }
  wfscnt = 0;
  WFSdelayWait = 1;

  fp = fopen("result.log", "w");
  fclose(fp);
  
  while (rtime < etime)
    {
      framef = rtime/WFTIME_STEP;
      frame = (long) framef;
      framefrac = framef-frame;

      // compute current OPD map for WFS      
      frame0 = frame;
      frame1 = frame+1;
      frameindex0 = frame0-cubeindex0*CubeSize;
      frameindex1 = frame1-cubeindex1*CubeSize;

      printf("time = %2.10g s  (%04ld %04ld) (%04ld %04ld) %1.6f\n", rtime, frameindex0, cubeindex0, frameindex1, cubeindex1, framefrac);

      while(frameindex0>CubeSize-1)
	{
	  cubeindex0 ++;
	  frameindex0 -= CubeSize;
	}

      while(frameindex1>CubeSize-1)
	{
	  cubeindex1 ++;
	  frameindex1 -= CubeSize;
	}


      sprintf(imname, "wfa%08ld",cubeindex0);
      IDac0 = image_ID(imname);
      if(IDac0 == -1)
	{
	  sprintf(fname, "%s/WF%04ld/WF4096/wf_%08ld.amp", WFDIRECTORY, WFSLAMBDA, cubeindex0);
	  printf("LOADING %s\n", fname);
	  IDac0 = load_fits(fname, imname);
	}
      sprintf(imname, "wfa%08ld",cubeindex1);
      IDac1 = image_ID(imname);
      if(IDac1 == -1)
	{
	  sprintf(fname, "%s/WF%04ld/WF4096/wf_%08ld.amp", WFDIRECTORY, WFSLAMBDA, cubeindex1);
	  printf("LOADING %s\n", fname);
	  IDac1 = load_fits(fname, imname);
	}

      sprintf(imname, "wfp%08ld",cubeindex0);
      IDpc0 = image_ID(imname);
      if(IDpc0 == -1)
	{
	  sprintf(fname, "%s/WF%04ld/WF4096/wf_%08ld.pha", WFDIRECTORY, WFSLAMBDA, cubeindex0);
	  printf("LOADING %s\n", fname);
	  IDpc0 = load_fits(fname, imname);
	}
      sprintf(imname, "wfp%08ld",cubeindex1);
      IDpc1 = image_ID(imname);
      if(IDpc1 == -1)
	{
	  sprintf(fname, "%s/WF%04ld/WF4096/wf_%08ld.pha", WFDIRECTORY, WFSLAMBDA, cubeindex1);
	  printf("LOADING %s\n", fname);
	  IDpc1 = load_fits(fname, imname);
	}




      sprintf(imname, "swfa%08ld",cubeindex0);
      IDacs0 = image_ID(imname);
      if(IDacs0 == -1)
	{
	  sprintf(fname, "%s/WF%04ld/WF4096/wf_%08ld.amp", WFDIRECTORY, SCILAMBDA, cubeindex0);
	  printf("LOADING %s\n", fname);
	  IDacs0 = load_fits(fname, imname);
	}
      sprintf(imname, "swfa%08ld",cubeindex1);
      IDacs1 = image_ID(imname);
      if(IDacs1 == -1)
	{
	  sprintf(fname, "%s/WF%04ld/WF4096/wf_%08ld.amp", WFDIRECTORY, SCILAMBDA, cubeindex1);
	  printf("LOADING %s\n", fname);
	  IDacs1 = load_fits(fname, imname);
	}

      sprintf(imname, "swfp%08ld",cubeindex0);
      IDpcs0 = image_ID(imname);
      if(IDpcs0 == -1)
	{
	  sprintf(fname, "%s/WF%04ld/WF4096/wf_%08ld.pha", WFDIRECTORY, SCILAMBDA, cubeindex0);
	  printf("LOADING %s\n", fname);
	  IDpcs0 = load_fits(fname, imname);
	}
      sprintf(imname, "swfp%08ld",cubeindex1);
      IDpcs1 = image_ID(imname);
      if(IDpcs1 == -1)
	{
	  sprintf(fname, "%s/WF%04ld/WF4096/wf_%08ld.pha", WFDIRECTORY, SCILAMBDA, cubeindex1);
	  printf("LOADING %s\n", fname);
	  IDpcs1 = load_fits(fname, imname);
	}



      if(cubeindex0>0)
	{
	  sprintf(imname, "wfa%08ld",cubeindex0-1);
	  IDtmp = image_ID(imname);
	  if(IDtmp!=-1)
	    delete_image_ID(imname);

	  sprintf(imname, "wfp%08ld",cubeindex0-1);
	  IDtmp = image_ID(imname);
	  if(IDtmp!=-1)
	    delete_image_ID(imname);

	  sprintf(imname, "swfa%08ld",cubeindex0-1);
	  IDtmp = image_ID(imname);
	  if(IDtmp!=-1)
	    delete_image_ID(imname);

	  sprintf(imname, "swfp%08ld",cubeindex0-1);
	  IDtmp = image_ID(imname);
	  if(IDtmp!=-1)
	    delete_image_ID(imname);	  
	}

      
      if(BINWF==1)
	{
	  for(ii=0;ii<WFsize*WFsize;ii++)
	    {
	      val0 = data.image[IDac0].array.F[frameindex0*WFsize*WFsize+ii];
	      val1 = data.image[IDac1].array.F[frameindex1*WFsize*WFsize+ii];
	      amp = (1.0-framefrac)*val0 + framefrac*val1;
	      
	      val0 = data.image[IDpc0].array.F[frameindex0*WFsize*WFsize+ii];
	      val1 = data.image[IDpc1].array.F[frameindex1*WFsize*WFsize+ii];
	      pha = (1.0-framefrac)*val0 + framefrac*val1;
	      
	      
	      data.image[IDatm_amp].array.F[ii] = amp;
	      data.image[IDatm_opd].array.F[ii] = pha/2.0/M_PI*LAMBDA;
	      
	      
	      val0 = data.image[IDacs0].array.F[frameindex0*WFsize*WFsize+ii];
	      val1 = data.image[IDacs1].array.F[frameindex1*WFsize*WFsize+ii];
	      amp = (1.0-framefrac)*val0 + framefrac*val1;
	      
	      val0 = data.image[IDpcs0].array.F[frameindex0*WFsize*WFsize+ii];
	      val1 = data.image[IDpcs1].array.F[frameindex1*WFsize*WFsize+ii];
	      pha = (1.0-framefrac)*val0 + framefrac*val1;
	      
	      data.image[IDatm_amp_sci].array.F[ii] = amp;
	      data.image[IDatm_opd_sci].array.F[ii] = pha/2.0/M_PI*(1.0e-9*SCILAMBDA);
	    }
	}
      else
	{
	  for(ii1=0;ii1<WFsize1;ii1++)
	    for(jj1=0;jj1<WFsize1;jj1++)	      
	      {
		re = 0.0;
		im = 0.0;
		re_sci = 0.0;
		im_sci = 0.0;
		pha_ave = 0.0;
		pha_ave_sci = 0.0;

		for(i=0;i<BINWF;i++)
		  for(j=0;j<BINWF;j++)
		    {
		      ii = ii1*BINWF+i;
		      jj = jj1*BINWF+j;
		      
		      val0 = data.image[IDac0].array.F[frameindex0*WFsize*WFsize+jj*WFsize+ii];
		      val1 = data.image[IDac1].array.F[frameindex1*WFsize*WFsize+jj*WFsize+ii];
		      amp = (1.0-framefrac)*val0 + framefrac*val1;
		      
		      val0 = data.image[IDpc0].array.F[frameindex0*WFsize*WFsize+jj*WFsize+ii];
		      val1 = data.image[IDpc1].array.F[frameindex1*WFsize*WFsize+jj*WFsize+ii];
		      pha = (1.0-framefrac)*val0 + framefrac*val1;
	  
		      re += amp*cos(pha);
		      im += amp*sin(pha);
		      pha_ave += pha;
		      
		      
		      val0 = data.image[IDacs0].array.F[frameindex0*WFsize*WFsize+jj*WFsize+ii];
		      val1 = data.image[IDacs1].array.F[frameindex1*WFsize*WFsize+jj*WFsize+ii];
		      amp = (1.0-framefrac)*val0 + framefrac*val1;
		
		      val0 = data.image[IDpcs0].array.F[frameindex0*WFsize*WFsize+jj*WFsize+ii];
		      val1 = data.image[IDpcs1].array.F[frameindex1*WFsize*WFsize+jj*WFsize+ii];
		      pha = (1.0-framefrac)*val0 + framefrac*val1;
		      
		      re_sci += amp*cos(pha);
		      im_sci += amp*sin(pha);
		      pha_ave_sci += pha;
		    }
		re /= (BINWF*BINWF);
		im /= (BINWF*BINWF);
		re_sci /= (BINWF*BINWF);
		im_sci /= (BINWF*BINWF);
		pha_ave /= (BINWF*BINWF);
		pha_ave_sci /= (BINWF*BINWF);

		data.image[IDatm_amp].array.F[jj1*WFsize1+ii1] = sqrt(re*re+im*im);
		pha = pha_ave;
		errpha = atan2(im,re)-pha_ave; // close to -2PI, 0, 2PI etc...
		errpha = modf(errpha/(2.0*M_PI),&tmpd);
		if(errpha>0.5)
		  errpha -= 1.0;
		if(errpha<-0.5)
		  errpha += 1.0;
		pha += errpha*2.0*M_PI;
		data.image[IDatm_opd].array.F[jj1*WFsize1+ii1] = pha/2.0/M_PI*LAMBDA;
		
		
		data.image[IDatm_amp_sci].array.F[jj1*WFsize1+ii1] = sqrt(re_sci*re_sci+im_sci*im_sci);
		pha = pha_ave_sci;
		errpha = atan2(im_sci,re_sci)-pha_ave_sci; // close to -2PI, 0, 2PI etc...
		errpha = modf(errpha/(2.0*M_PI),&tmpd);
		if(errpha>0.5)
		  errpha -= 1.0;
		if(errpha<-0.5)
		  errpha += 1.0;
		pha += errpha*2.0*M_PI;
		data.image[IDatm_opd_sci].array.F[jj1*WFsize1+ii1] = pha/2.0/M_PI*(1.0e-9*SCILAMBDA);		
	      }
	}

      //    save_fl_fits("atmopdsci","!test_atmopdsci.fits");
      //save_fl_fits("atmampsci","!test_atmampsci.fits");
      

      // Apply DM
      for(ii=0;ii<WFsize1*WFsize1;ii++)
	{
	  data.image[IDwfs_opd].array.F[ii] = data.image[IDatm_opd].array.F[ii] - data.image[IDdm_opd].array.F[ii];
	  data.image[IDsci_opd].array.F[ii] = data.image[IDatm_opd_sci].array.F[ii] - data.image[IDdm_opd].array.F[ii];
	}


      // WFS integration
      for(ii=0;ii<WFsize1*WFsize1;ii++)
	data.image[IDwfs_mes_opd].array.F[ii] += data.image[IDwfs_opd].array.F[ii];
      wfscnt++;
      
      

      if(wfstime>WFS_SamplingTime) // WFS measurement
	{
	
	  // ADD WFS NOISE HERE
	  //
	  //

	  if(PIDok == 1)
	    {
	      for(ii=0;ii<WFsize1*WFsize1;ii++)
		{
		  data.image[IDwfs_mes_opd].array.F[ii] /= wfscnt; // AVERAGE OVER WFS INTEGRATION TIME
		  data.image[IDwfs_mes_opd_derivative].array.F[ii] = (1.0-Kdgain)*data.image[IDwfs_mes_opd_derivative].array.F[ii] + Kdgain*(data.image[IDwfs_mes_opd].array.F[ii]-data.image[IDwfs_mes_opd_prev].array.F[ii])/WFS_SamplingTime;
		  data.image[IDwfs_mes_opd_integral].array.F[ii] += WFS_SamplingTime*data.image[IDwfs_mes_opd].array.F[ii];
		}
	    }
	  else
	    {
	      for(ii=0;ii<WFsize1*WFsize1;ii++)
		{
		  data.image[IDwfs_mes_opd].array.F[ii] /= wfscnt; // AVERAGE OVER WFS INTEGRATION TIME
		  data.image[IDwfs_mes_opd_derivative].array.F[ii] = 0.0;
		  data.image[IDwfs_mes_opd_integral].array.F[ii] += WFS_SamplingTime*data.image[IDwfs_mes_opd].array.F[ii];
		}
	      PIDok = 1;
	    }




	  for(ii=0;ii<WFsize1*WFsize1;ii++)
	    {
	      data.image[IDdm_opd_tmp].array.F[ii] += Kp*data.image[IDwfs_mes_opd].array.F[ii] + Kd*data.image[IDwfs_mes_opd_derivative].array.F[ii]*WFS_SamplingTime;
	      data.image[IDwfs_mes_opd].array.F[ii] = 0.0;
	    }
	  wfscnt = 0.0;
	  wfstime = 0.0;
	  WFSdelayWait = 1; // start wait
	  wfstime1 = 0.0;



	  for(ii=0;ii<WFsize1*WFsize1;ii++)
	    data.image[IDwfs_mes_opd_prev].array.F[ii] = data.image[IDwfs_mes_opd].array.F[ii]; // PREVIOUS WFS MEASUREMENT
	}

      if((wfstime1>WFS_Delay)&&(WFSdelayWait==1))
	{
	  printf("UPDATE DM SHAPE\n");
	  WFSdelayWait = 0;
	  for(ii=0;ii<WFsize1*WFsize1;ii++)
	    data.image[IDdm_opd].array.F[ii] = data.image[IDdm_opd_tmp].array.F[ii];
	}

      // MEASURE WF QUALITY
      val0 = 0.0;
      val1 = 0.0;
      for(ii=0;ii<WFsize1*WFsize1;ii++)
	{
	  val0 += data.image[IDwfs_opd].array.F[ii]*data.image[IDtelpup].array.F[ii];
	  val1 += data.image[IDtelpup].array.F[ii];	  
	}
      for(ii=0;ii<WFsize1*WFsize1;ii++) // REMOVE PISTON
	data.image[IDwfs_opd].array.F[ii] -= val0/val1;

      val0 = 0.0;
      val1 = 0.0;
      for(ii=0;ii<WFsize1*WFsize1;ii++) // COMPUTE RMS WF QUALITY
	{
	  val0 += data.image[IDsci_opd].array.F[ii]*data.image[IDsci_opd].array.F[ii]*data.image[IDtelpup].array.F[ii];
	  val1 += data.image[IDtelpup].array.F[ii];	  
	}
      RMSwf = sqrt(val0/val1);
      
      //    tp("0.0");

     printf("WAVEFRONT QUALITY = %g m\n", RMSwf);
      fp = fopen("result.log", "a");
      fprintf(fp,"%10.10g %g\n", rtime, RMSwf);
      fclose(fp);

      if(rtime>etimestart)
	{
	  value += RMSwf;
	  valuecnt ++;
	}
      

      // MAKING FOCAL PLANE IMAGE
      //printf("%ld %ld\n", sizeb, WFsize1);
      // list_image_ID();
      //    printf("Image identifiers: %ld %ld %ld %ld %ld\n", IDpupa, IDpupp, IDtelpup, IDatm_amp_sci, IDsci_opd);
      fflush(stdout);
      
      tot = 0.0;
      for(ii=0; ii<sizeb; ii++)
	for(jj=0; jj<sizeb; jj++)
	  {
	    ii1 = WFsize1/2-sizeb/2+ii;
	    jj1 = WFsize1/2-sizeb/2+jj;
	    if((ii1>-1)&&(jj1>-1)&&(ii1<WFsize1)&&(jj1<WFsize1))
	      {
		data.image[IDpupa].array.F[jj*sizeb+ii] = data.image[IDtelpup].array.F[jj1*WFsize1+ii1]*data.image[IDatm_amp_sci].array.F[jj1*WFsize1+ii1];
		tot += data.image[IDpupa].array.F[jj*sizeb+ii];
		data.image[IDpupp].array.F[jj*sizeb+ii] = data.image[IDtelpup].array.F[jj1*WFsize1+ii1]*2.0*M_PI*data.image[IDsci_opd].array.F[jj1*WFsize1+ii1]/(1.0e-9*SCILAMBDA);	    
	      }
	  }
      
      //      tp("0.5");

      mk_reim_from_amph("pupa","pupp", "pupre","pupim");
      basic_contract("pupre","pupre1",BINFACTOR,BINFACTOR);
      basic_contract("pupim","pupim1",BINFACTOR,BINFACTOR);
      delete_image_ID("pupre");
      delete_image_ID("pupim");
      mk_complex_from_reim("pupre1", "pupim1", "pupc");
      permut("pupc");
      do2dfft("pupc","focc");
      permut("focc");
      delete_image_ID("pupc");
      mk_amph_from_complex("focc","foca","focp");
      delete_image_ID("focc");
      delete_image_ID("focp");
      execute_arith("foci=foca*foca");
      delete_image_ID("foca");
      
      ID = image_ID("foci");
      IDpsfcumul = image_ID("PSFcumul");


      //      tp("1.0");


      // MAKING CORONAGRAPHIC FOCAL PLANE IMAGE
      // USING SIMPLE CORONAGRAPH MODEL REMOVING PERFECTLY MODE 0
      IDre = image_ID("pupre1");
      IDim = image_ID("pupim1");
      peak = 0.0;
      for(ii=0;ii<size*size;ii++)
	{
	  re = data.image[IDre].array.F[ii];
	  im = data.image[IDim].array.F[ii];	  
	  amp = re*re+im*im;
	  if(amp>peak)
	    peak = amp;
	}
      reave = 0.0;
      imave = 0.0;
      cnt = 0;
      for(ii=0;ii<size*size;ii++)
	{
	  re = data.image[IDre].array.F[ii];
	  im = data.image[IDim].array.F[ii];	  
	  reave += re;
	  imave += im;
	  amp = re*re+im*im;
	  if(amp>0.2*peak)
	    cnt ++;
	}
      reave /= cnt;
      imave /= cnt;
      for(ii=0;ii<size*size;ii++)
	{
	  re = data.image[IDre].array.F[ii];
	  im = data.image[IDim].array.F[ii];	  
	  amp = re*re+im*im;
	  if(amp>0.2*peak)
	    {
	      data.image[IDre].array.F[ii] -= reave;
	      data.image[IDim].array.F[ii] -= imave;	  
	    }
	}
      mk_complex_from_reim("pupre1", "pupim1", "pupc");
      permut("pupc");
      do2dfft("pupc","focc");
      permut("focc");
      delete_image_ID("pupc");
      mk_amph_from_complex("focc","foca","focp");
      delete_image_ID("focc");
      delete_image_ID("focp");
      execute_arith("focic=foca*foca");
      delete_image_ID("foca");
      delete_image_ID("pupre1");
      delete_image_ID("pupim1");

      
      ID = image_ID("foci");
      ID1 = image_ID("focic");
      peak = 1.0;
      if(rtime>etimestart)
	{
	  peak = 0.0;
	  for(ii=0;ii<size*size;ii++)
	    {	
	      data.image[IDpsfcumul].array.F[ii] += data.image[ID].array.F[ii];
	      data.image[IDpsfcumul1].array.F[ii] += data.image[ID1].array.F[ii];
	      if(data.image[IDpsfcumul].array.F[ii]>peak)
		peak = data.image[IDpsfcumul].array.F[ii];
	    }
	}


      // SAVING RESULT
      if(1)
	{
	  sprintf(fname, "!psf/psf_%1.10lf.fits", rtime);
	  save_fl_fits("foci",fname);
	  printf("tot = %g\n", tot);

	  
	  if(rtime>etimestart)
	    {
	      tot = (rtime-etimestart)*FLUXSCI; // total flux in image [ph]
	      arith_image_cstmult("PSFcumul",1.0/peak,"PSFcumuln");
	      save_fl_fits("PSFcumuln", "!PSFcumul.fits"); // normalized in contrast 
	      tot0 = arith_image_total("PSFcumuln");	      
	      arith_image_cstmult_inplace("PSFcumuln",tot/tot0); // normalized to tot
	      put_poisson_noise("PSFcumuln","PSFcumulnn");
	      arith_image_cstmult_inplace("PSFcumulnn",tot0/tot); // re-normalized in contrast
	      delete_image_ID("PSFcumuln");
	      save_fl_fits("PSFcumulnn", "!PSFcumul_n.fits");
	   
	      arith_image_cstmult("PSFcumul1",1.0/peak,"PSFcumul1n");
	      save_fl_fits("PSFcumul1n", "!PSFcumul1.fits");
	      arith_image_cstmult_inplace("PSFcumul1n",tot/tot0);
	      put_poisson_noise("PSFcumul1n","PSFcumul1nn");
	      arith_image_cstmult_inplace("PSFcumul1nn",tot0/tot);
	      delete_image_ID("PSFcumul1n");
	      save_fl_fits("PSFcumul1nn", "!PSFcumul1_n.fits");
	    }
	}

      rtime += dtime;
      wfstime += dtime;
      wfstime1 += dtime;

    }


  delete_image_ID("TelPup");
  delete_image_ID("atmopd");
  delete_image_ID("atmamp");
  delete_image_ID("atmopdsci");
  delete_image_ID("atmampsci");
  delete_image_ID("wfsopd");
  delete_image_ID("wfsamp");
  delete_image_ID("dmopdtmp");
  delete_image_ID("dmopd");
  delete_image_ID("wfsmesopd");
  delete_image_ID("wfsmesopdprev");
  delete_image_ID("wfsmesopdder");
  delete_image_ID("wfsmesopdint");
  delete_image_ID("sciopd");
  delete_image_ID("sciamp");
  delete_image_ID("pupa");
  delete_image_ID("pupp");
  delete_image_ID("PSFcumul");
  delete_image_ID("PSFcumul1");
  delete_image_ID("PSFcumulnn");
  delete_image_ID("PSFcumul1nn");
  delete_image_ID("focic");
  delete_image_ID("foci");



  sprintf(imname, "wfa%08ld",cubeindex0);
  IDtmp = image_ID(imname);
  if(IDtmp!=-1)
    delete_image_ID(imname);
  
  sprintf(imname, "wfp%08ld",cubeindex0);
  IDtmp = image_ID(imname);
  if(IDtmp!=-1)
    delete_image_ID(imname);
  
  sprintf(imname, "swfa%08ld",cubeindex0);
  IDtmp = image_ID(imname);
  if(IDtmp!=-1)
    delete_image_ID(imname);
  
  sprintf(imname, "swfp%08ld",cubeindex0);
  IDtmp = image_ID(imname);
  if(IDtmp!=-1)
    delete_image_ID(imname);	  

  sprintf(imname, "wfa%08ld",cubeindex1);
  IDtmp = image_ID(imname);
  if(IDtmp!=-1)
    delete_image_ID(imname);
  
  sprintf(imname, "wfp%08ld",cubeindex1);
  IDtmp = image_ID(imname);
  if(IDtmp!=-1)
    delete_image_ID(imname);
  
  sprintf(imname, "swfa%08ld",cubeindex1);
  IDtmp = image_ID(imname);
  if(IDtmp!=-1)
    delete_image_ID(imname);
  
  sprintf(imname, "swfp%08ld",cubeindex1);
  IDtmp = image_ID(imname);
  if(IDtmp!=-1)
    delete_image_ID(imname);	  



  return(value/valuecnt);
}


// custom AO related processing of a series of WF

int AtmosphericTurbulence_WFprocess()
{
  FILE *fp;
  char wf_file_name[200];
  long ID;
  long k, kk;
  double time;
  long size, sizec;
  int OK;
  char command[500];
  double pupsize;


  double Kp, Ki, Kd, Kdgain;
  double val; 
  long iter; 

  int r;



  // Std loop (no PID)
  Kp = 0.5;
  Ki = 0.0;
  Kd = 0.0;
  val = AtmosphericTurbulence_makePSF(Kp, Ki, Kd, Kdgain);
  exit(0);
  


  printf("CUSTOM PROCESSING\n");
  for(iter=15;iter<1000;iter++)
    {      
      Kp = ran1(); //0.35; // loop gain
      Ki = ran1(); //0.0;
      Kd = ran1(); //0.1;
      Kdgain = ran1(); //0.5;
      
      Kp = 0.3;
      Ki = 0.0;
      Kd = 0.0;// ran1();
      //Kdgain = 0.5;


      val = AtmosphericTurbulence_makePSF(Kp, Ki, Kd, Kdgain);
      
      fp = fopen("res.log.txt","a");
      fprintf(fp, "%ld %e %e %e %e %e\n", iter, Kp, Ki, Kd, Kdgain, val);
      fclose(fp);
      sprintf(command, "cp result.log result_%05ld.log", iter);
      r = system(command);
    
      list_image_ID();
      exit(0);
    }
  
  OK = 1;
  k = 0;
  while(OK==1)
    {
      sprintf(wf_file_name,"wf550_%08ld.pha",k);
      ID = load_fits(wf_file_name,"tpmwfc");
      if(ID==-1)
	{
	  OK = 0;
	}
      else
	{
	  size = data.image[ID].md[0].size[0];
	  sizec = data.image[ID].md[0].size[2];
	  printf("%ld  %ld %ld\n",k,size,sizec);
	  
	  for(kk=0;kk<sizec;kk++)
	    {
	      
	    }
	  
	  delete_image_ID("tmpwfc");
	}
      k++;
    }

  return(0);
}
